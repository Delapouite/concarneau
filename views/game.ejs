<!doctype html>
<html>
<head>
    <script type="text/javascript">
    // if Facebook redirect hash is present remove it: https://stackoverflow.com/questions/7131909/facebook-callback-appends-to-return-url
    if (window.location.hash && window.location.hash == '#_=_') {
        if (window.history && history.pushState) {
            window.history.pushState("", document.title, window.location.pathname);
        } else {
            window.location.hash = '';
        }
    }
	</script>
    <title>Concarneau</title>
    <link rel="shortcut icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" type='text/css'>
    <link rel="stylesheet" href="/content/css/game.css" type='text/css'>
</head>
<body>
<div id="wrapper">
<div id="menus">
	<div id="game-menu">
		<span class="menu-header">GAMES <i class="fa fa-edit hidden" onclick="enableGamesEdit(event)"></i> <i class="fa fa-plus-square-o"></i></span>
		<div id="active-games">
			<div class="menu-sub-header">Your move:</div>
		</div>
		<div id="inactive-games">
			<div class="menu-sub-header">Waiting on move:</div>
		</div>
		<div id="finished-games">
			<div class="menu-sub-header">Finished:</div>
		</div>
		<!--<div>
			<input type="checkbox" id="test-complete" />
		</div>-->
	</div>
	<div id="friends-menu">
		<span class="menu-header">FRIENDS <i class="fa fa-edit hidden" onclick="enableFriendsEdit(event)"></i></span>
		<form id="add-friend-form">
			<div class="input-group">
				<input type="text" class="form-control" id="add-friend-input" placeholder="Username" autocomplete="off">
				<span class="input-group-btn">
					<button class="btn btn-default" type="submit">Add</button>
				</span>
			</div>
		</form>
		<div id="username-alert" class="alert">Placeholder text</div>
		<div id="friends-list"></div>
	</div>
	<div id="settings-menu">
		<span class="menu-header">SETTINGS</span>
		<a href="/profile">Profile</a>
		<div class="checkbox">
			<label>
				<input type="checkbox" 
				       onclick="socket.emit('email notification', this.checked)"
				       <%- user.email_notifications ? 'checked="true"' : '' %>
				       <%- !(user.facebook.email || user.google.email || user.local.email) ? 'disabled' : '' %>> E-mail notifications
			</label>
			<%- !(user.facebook.email || user.google.email || user.local.email) ? '(requires non-Twitter login linked in Profile)' : '' %>
		</div>
		<div class="checkbox">
			<label>
				<input type="checkbox" 
				       onclick="socket.emit('twitter notification', this.checked)"
				       <%- user.twitter_notifications ? 'checked="true"' : '' %>
				       <%- !user.twitter.username ? 'disabled' : '' %>> Twitter notifications
			</label>
			<%- !user.twitter.username ? '(requires Twitter login linked in Profile)' : '' %>
		</div>
		<a href="/logout">Logout</a>
	</div>
</div>
<div id="menu-selection">
	<div id="game-menu-selection" class="iconmelon" onclick="menuClick('#game-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-templates"></use>
		</svg>
	</div>
	<div id="friends-menu-selection" class="iconmelon" onclick="menuClick('#friends-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-environment"></use>
		</svg>
	</div>
	<div id="settings-menu-selection" class="iconmelon" onclick="menuClick('#settings-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-settings"></use>
		</svg>
	</div>
</div>
<div id="author-info">
	<div>
		Created by <span id="author-name">Brian Ouellette</span>
		<a href="http://github.com/btouellette/concarneau"><img height="25" width="25" src="/content/images/ui/github_logo.png" /></a>
	</div>
	<span>Buy me a beer?</span>
	<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
		<input type="hidden" name="cmd" value="_donations">
		<input type="hidden" name="business" value="btouellette@gmail.com">
		<input type="hidden" name="lc" value="US">
		<input type="hidden" name="item_name" value="Concarneau">
		<input type="hidden" name="no_note" value="0">
		<input type="hidden" name="currency_code" value="USD">
		<input type="hidden" name="bn" value="PP-DonationsBF:paypal-icon.png:NonHostedGuest">
		<input type="image" height="25" width="25" src="/content/images/ui/paypal_logo.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
	</form>
	<img id="btc-donate" height="25" width="25" src="/content/images/ui/bitcoin_logo.png" />
</div>
<div id="svg-wrapper">
	<svg id="game-svg" width="100%" height="100%">
		<defs>
			<pattern id="thin-stripes-pattern" width="5" height="5" patternUnits="userSpaceOnUse">
				<rect width="5" height="5" fill="#f5f5f5"></rect>
				<path d="M0 5L5 0ZM6 4L4 6ZM-1 1L1 -1Z" stroke="#e0e0e0"></path>
			</pattern>
		</defs>
		<rect width="100%" height="100%" fill="url(#thin-stripes-pattern)" id="game-background"></rect>
	</svg>
</div>
<div id="chat-wrapper" class="panel panel-primary hidden">
	<div id="chat-header" class="panel-heading">
		<div id="chat-header-label"><i class="fa fa-comments"></i><span> Chat</span></div>
        <div id="chat-toggle" class="btn-group">
            <a class="btn btn-default btn-xs" onclick="$('#chat-body,#chat-footer').toggle()">
                <i class="fa fa-chevron-down"></i>
            </a>
        </div>
    </div>
	<div id="chat-body">
		<ul id="chat-message-list">
		</ul>
	</div>
	<div id="chat-footer">
		<form id="chat-message-form">
			<div class="input-group">
				<input id="chat-message-input" type="text" class="form-control input-sm" maxlength="200" placeholder="Type your message here...">
				<span class="input-group-btn">
					<button class="btn btn-sm btn-info" type="submit">Send</button>
				</span>
			</div>
		</form>
	</div>
</div>
</div>
<script src="https://cdn.socket.io/socket.io-1.0.6.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.8/d3.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
<script>
//TODO: show socket status on page
//TODO: show player online status
//TODO: show player avatars (gravatars?)
//TODO: Modernizr and noscript redirects
//TODO: move these variables out of the global namespace (add onclick to elements via JS)
//TODO: zoom and pan when active tile moves if out of zoom/pan range
//TODO: default zoom level should be dependendent on number of placed tiles
//TODO: see if there is a way to prevent the image rerender across the board when the active tile is scaled
//TODO: add keyboard shortcuts ENTER = place tile, arrows = pan
//TODO: concede button
//TODO: list points on the board
//TODO: activatable overlay showing count of tiles that could fit in a space
//TODO: add welcome popup explaining buttons and linking to rules if 0 games and 0 friends, allow to view again from settings
//TODO: scoreboard/game record
//TODO: You win! or You lost! alert when game is finished (with rematch button)
var userGames = <%- JSON.stringify(user.activeGames) %>;
var userFriends = <%- JSON.stringify(user.friends) %>;
var userID = '<%- user._id %>';
var socket = io.connect('<%- process.env.SOCKET_URL %>');

var currentGameID, selectedMove, svgHeight, svgWidth;
var usingLargeMeeple = false;
var reverseScale = 1;
var reverseTranslation = [0,0];
var transitionDuration = 750;
var tileSize = 100;

function menuClick(menuToOpen, button) {
	$('#menus > div').hide();
	$(menuToOpen).show();
	$('#menu-selection > div').css('fill','#272727');
	$(button).css('fill','#808080');
}

function enableFriendsEdit(e) {
	$('#friends-list .fa-user').removeClass('fa-user').addClass('fa-trash-o').css('cursor', 'pointer').on('click', function () {
		socket.emit('remove friend', this.parentNode.id.substr(7));
		$(this.parentNode).remove();
	    if($('.friend-listing').length === 0) {
	    	$('#friends-menu .fa-edit').addClass('hidden');
	    }
	});
	$(window).on('click.friend-edit', function() {
		disableFriendsEdit();	
	});
	e.stopPropagation();
}

function disableFriendsEdit() {
	$('#friends-list .fa-trash-o').removeClass('fa-trash-o').addClass('fa-user').css('cursor', '').off('click');
	$(window).off('click.friend-edit');
}

function enableGamesEdit(e) {
	$('#game-menu .tile-count').hide();
	$('#game-menu .fa-trash-o').removeClass('hidden').on('click', function () {
		var gameID = this.parentNode.parentNode.id.substr(5);
		socket.emit('remove game', gameID);
		$(this.parentNode.parentNode).remove();
		// if we deleted the game we are viewing remove relevant svg elements
		if(gameID === currentGameID) {
			resetActiveTile(false);
			$('#placed-tiles,#turn-markers,#valid-placements,#meeple-placements').empty();
			$('.score-group').remove();
			d3.select('#score-bg').attr('opacity', 0);
			$('#active-tile-image').remove();
		}
		// if there are no more games hide the edit/delete button
		if($('.menu-game-listing').length === 0) {
			$('#game-menu .fa-edit').addClass('hidden');
		}
	});
	$(window).on('click.games-edit', function() {
		disableGamesEdit();	
	});
	e.stopPropagation();
}

function disableGamesEdit() {
	$('#game-menu .fa-trash-o').addClass('hidden').off('click');
	$('#game-menu .tile-count').show();
	$(window).off('click.games-edit');
}

(function ($) {
    // debouncedresize: special jQuery event that happens once after a window resize
    // https://github.com/louisremi/jquery-smartresize
    // Copyright 2012 @louis_remi
    // Licensed under the MIT license.
    var $event = $.event,
        $special,
        resizeTimeout;
    $special = $event.special.debouncedresize = {
        setup: function () { $(this).on("resize", $special.handler); },
        teardown: function () { $(this).off("resize", $special.handler); },
        handler: function (event, execAsap) {
            // Save the context
            var context = this,
                    args = arguments,
                    dispatch = function () {
                        // set correct event type
                        event.type = "debouncedresize";
                        $event.dispatch.apply(context, args);
                    };
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            execAsap ? dispatch() : resizeTimeout = setTimeout(dispatch, $special.threshold);
        },
        threshold: 150
    };
})(jQuery);
	
function resetActiveTile(withTransition) {
	// remove data stored regarding the active tile position
	$('#active-tile').removeData('rotationIndex').removeData('placementIndex');
	// hide any placed meeples and their outlines
	$('#meeple-placements').attr('visibility', 'hidden');
	$('#meeple-placements image').attr('visibility', 'hidden');
	// disable large meeple placement mode
	disableLargeMeeple();
	// show the meeples in the score area as they are no longer placed
	$('#score-area image').removeAttr('visibility');
	// remove any selected move
	selectedMove = null;
	
	if(withTransition) {
		var startingScale = reverseScale;
		var startingTranslationX = reverseTranslation[0];
		var startingTranslationY = reverseTranslation[1];
		d3.selectAll('#confirm-button,#send-move-button').transition().duration(transitionDuration).attr('opacity', 0);
		d3.selectAll('#confirm-button,#send-move-button').transition().delay(transitionDuration).attr('visibility', 'hidden');
		d3.selectAll('#confirm-button > *').transition().delay(transitionDuration).attr('visibility', null);
		d3.select('#active-tile').transition().duration(transitionDuration).attr({ 
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		}).each('end', function() {
			// check to see if zoom or pan has happened since this transition began and redraw if so
			if(reverseScale !== startingScale || 
			   reverseTranslation[0] !== startingTranslationX ||
			   reverseTranslation[1] !== startingTranslationY) {
				resetActiveTile(true);   	
	   		}
		});
		d3.select('#active-tile-rotation-indicator').transition().duration(transitionDuration).attr({
			opacity: 0,
			visibility: null
		});
	} else {
		d3.selectAll('#confirm-button,#send-move-button').transition().duration(0).attr({
			opacity: 0,
			visibility: 'hidden'
		});
		d3.selectAll('#confirm-button > *').attr('visibility', null);
		d3.select('#active-tile').attr({ 
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		});
		d3.select('#active-tile-rotation-indicator').attr({
			opacity: 0,
			visibility: null
		});
	}
}

function enableLargeMeeple() {
	// flag the large meeple as clicked and make meeple placements bigger
	usingLargeMeeple = true;
	d3.selectAll('#meeple-placements image').attr({
		width: tileSize * 3 / 8,
		height: tileSize * 3 / 8,
		x: -tileSize * 3 / 16,
		y: -tileSize * 3 / 16
	});
	// add on click to small meeples in score area to undo large meeple selection and remove click handler for enabling
	var firstScoreGroup = d3.select('.score-group');
	firstScoreGroup.selectAll('.remaining-meeple').attr({ cursor: 'pointer' }).on('click', disableLargeMeeple);
	firstScoreGroup.select('.remaining-large-meeple').attr({ cursor: null }).on('click', null);
	if(selectedMove && selectedMove.meeple) {
		// mark the move as using the large meeple
		selectedMove.meeple.large = true;
		// unhide the hidden small meeple in the score area
		$('.score-group image.remaining-meeple').first().attr('visibility', null);
		// hide the large meeple
		$('.score-group').first().find('.remaining-large-meeple').attr('visibility', 'hidden');
	}
}

function disableLargeMeeple() {
	// unflag the large meeple as clicked and make meeple placements smaller
	usingLargeMeeple = false;
	d3.selectAll('#meeple-placements image').attr({
		width: tileSize / 4,
		height: tileSize / 4,
		x: -tileSize / 8,
		y: -tileSize / 8
	});
	// add on click to large meeple in score area to enable large meeple selection and remove click handler for disabling
	var firstScoreGroup = d3.select('.score-group');
	firstScoreGroup.selectAll('.remaining-meeple').attr({ cursor: null }).on('click', null);
	firstScoreGroup.select('.remaining-large-meeple').attr({ cursor: 'pointer' }).on('click', enableLargeMeeple);
	if(selectedMove && selectedMove.meeple) {
		// unmark the move as using the large meeple
		selectedMove.meeple.large = false;
		// hide the first small meeple in the score area
		$('.score-group image.remaining-meeple').first().attr('visibility', 'hidden');
		// unhide the large meeple if it is present
		$('.remaining-large-meeple').attr('visibility', null);
	}
}

$(document).ready(function() {
	// maybe avoid getting some spam with this
	$('#author-name').replaceWith('<a href="mailto:' + 'btouellette+concarneau' + '@' + 'gmail.com' + '">Brian Ouellette</a>');
	
	$('#btc-donate').qtip({
		prerender: true,
		content: {
			text: '<img src="/content/images/ui/bitcoin_qr.png" class="btc-qr"></img>13C6vXxhQuSrGs628imU8ug2xvachM6pJ2'
		},
		style: {
			classes: 'qtip-bootstrap'
		},
		position: {
			my: 'bottom center',
			at: 'top center',
			viewport: $(window), 
            adjust: {
                method: 'shift'
            }
		},
		show: {
			event: 'mouseenter click',
			delay: 200
		},
		hide: {
			event: 'unfocus mouseleave',
			delay: 500
		},
		events: {
            render: function(event, api) {
            	$(this).attr('id', 'btc-popup');
                // detect when it was clicked and store it
                api.elements.target.click(function(e) { 
                    api.wasClicked = !api.wasClicked;
                });
            },
            hide: function(event, api) {
                // if we're hiding and it was previously clicked stop, if it gets hidden unset the clicked status
                if((api.wasClicked && (event.originalEvent.type === 'mouseleave' || event.originalEvent.type === 'mouseout')) ||
                   $('#btc-popup').is(":hover")) {
                    try{ event.preventDefault(); } catch(e) {}
                } else {
                	api.wasClicked = false;
                }
            }
        }
	});
	
	$('#game-menu .fa-plus-square-o').qtip({
		content: {
			text: '<div id="new-game-popup">' + 
			        '<div>Click friends to add to game:</div>' + 
			        '<div id="solo-notifier"><i class="fa fa-exclamation-triangle"></i> Currently playing solo</div>' + 
			      '</div>' + 
			      '<button type="button" id="new-game-cancel" class="btn btn-default btn-sm">Cancel</button>' + 
			      '<button id="new-game-send" type="button" class="btn btn-default btn-sm">Start</button>' +
			      '<div id="expansion-header">Expansions:</div>' +
			      '<label class="expansion-label">' + 
			        '<input type="checkbox" id="inns-and-cathedrals-checkbox" class="expansion-checkbox"> <a target="_blank" href="http://zmangames.com/rulebooks/Carcassonne_Exp1.pdf">Inns and Cathedrals</a>' + 
			      '</label>'
		},
		style: {
			classes: 'qtip-bootstrap',
			tip: {
				corner: false
			}
		},
		position: {
			my: 'left center',
			at: 'center right',
			viewport: $(window), 
            adjust: {
                method: 'shift',
                x: 225
            }
		},
		show: {
			event: 'click'
		},
		hide: {
			event: 'click'
		},
		events: {
			show: function() {
				$('#new-game-popup .friend-listing').remove();
				$('#friends-menu .fa-edit').hide();
				$('#friends-menu-selection').click();
				$('#friends-list .fa-user').removeClass('fa-user').addClass('fa-plus-square-o').css('cursor', 'pointer');
				$('#friends-list .friend-listing').on('click', function() {
					if($('#new-game-popup .friend-listing').length < 5) {
						$('#solo-notifier').hide();
						var element = $(this);
						element.clone().attr('id', 'add-' + element.attr('id')).css('cursor', 'default').addClass('add-friend-listing').appendTo('#new-game-popup');
					}
				});
			},
			hide: function() {
				$('#friends-menu .fa-edit').show();
				$('#game-menu-selection').click();
				$('#friends-list .fa-plus-square-o').removeClass('fa-plus-square-o').addClass('fa-user').css('cursor', '');
				$('#friends-list .friend-listing').off('click');
				$('#solo-notifier').delay(250).show(0);
			},
			render: function(e, api) {
                $('#new-game-cancel', this).click(function(event) {
                    api.hide(event);
                    event.preventDefault();
                });
                $('#new-game-send', this).click(function(event) {
                	var friends = [];
                	$('.add-friend-listing').each(function() {
                		friends.push(this.id.substr(11));
                	});
                	var expansions = ['base-game'];
                	$('.expansion-checkbox:checked').each(function() {
                		expansions.push(this.id.slice(0,-9));
                	});
                	socket.emit('new game', friends, expansions);
                	api.hide(event);
                	event.preventDefault();
                });
			}
		}
	});

	$('#add-friend-form').on('submit', function(e) {
		e.preventDefault();
		socket.emit('add friend', $('#add-friend-input').val());
	});
	
	$('#chat-message-form').on('submit', function(e) {
		e.preventDefault();
		var input = $('#chat-message-input');
		socket.emit('sending message', input.val(), currentGameID);
		input.val('');
	});

	// Load in SVG icons
	var c = new XMLHttpRequest();
	c.open('GET', '/content/images/ui/icons.svg', false);
	c.setRequestHeader('Content-Type', 'text/xml');
	c.send();
	document.body.insertBefore(c.responseXML.firstChild, document.body.firstChild);

    var lastGamestate;
    
    var zoom = d3.behavior.zoom().scaleExtent([0.25, 1]).on('zoom', function() {
    	//d3.event.sourceEvent.preventDefault();
		reverseScale = 1/d3.event.scale;
		reverseTranslation = d3.event.translate.map(function(item) { return -1 * item; });
		gameArea.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
		if(!selectedMove) {
			resetActiveTile(false);
		}
	});
	
    var svg = d3.select('#game-svg').call(zoom).on("dblclick.zoom", null);
	
	var gameArea = svg.append('g').attr({ id: 'game-area' });
    var placedTiles = gameArea.append('g').attr({ id: 'placed-tiles' });
    var turnMarkerArea = gameArea.append('g').attr({ id: 'turn-markers' });
	var placements = gameArea.append('g').attr({ id: 'valid-placements' });
    var activeTileContainer = gameArea.append('g').attr({ id: 'active-tile' });
    var activeTileImageContainer = activeTileContainer.append('g').attr({ id: 'active-tile-translation', transform: 'translate(' + tileSize / 2 + ',' + tileSize / 2 + ')' })
                                                      .append('g').attr({ id: 'active-tile-rotation' });
    activeTileImageContainer.append('use').attr({
    	id: 'active-tile-rotation-indicator',
    	'xlink:href': '#svgicon-repeat-payment',
		x: -16,
		y: -16,
    	transform: 'scale(' + tileSize / 32 + ')',
    	fill: 'white',
    	stroke: 'black',
    	opacity: 0,
    	'pointer-events': 'none'
    });
    var meeplePlacements = activeTileImageContainer.append('g').attr({ 
    	id: 'meeple-placements', 
    	visibility: 'hidden' 
	});
	
    var uiArea = svg.append('g').attr({ id: 'ui-area' });
    var scoreArea = uiArea.append('g').attr({ id: 'score-area' });
    scoreArea.append('rect').attr({
    	id: 'score-bg',
    	rx: 15,
    	ry: 15,
    	x: -15,
    	y: -15,
    	fill: 'white',
    	stroke: 'black',
    	'stroke-width': 2,
    	opacity: 0.75
    });
    var sendMoveButton = uiArea.append('g').attr({
    	id: 'send-move-button',
    	cursor: 'pointer',
    	visibility: 'hidden'
    }).on('click', function() {
    	if(selectedMove) {
    		socket.emit('sending move', currentGameID, selectedMove, $('#test-complete').is(':checked'));
    		// while waiting for the next gamestate hide any tile placements and the send move button
			d3.selectAll('#send-move-button,.tile-placements').transition().duration(transitionDuration+1500).attr('opacity', 0);
    	}
    });
    sendMoveButton.append('circle').attr({
    	cy: 5 + tileSize / 2,
    	cx: $('#svg-wrapper').width() - 5 - tileSize / 2,
    	r: 30,
    	fill: 'green',
    	stroke: 'black',
    	'stroke-width': 5
    });
    sendMoveButton.append('use').attr({
    	'xlink:href': '#svgicon-transfer',
    	x: $('#svg-wrapper').width() - 5 - tileSize / 2 - 16,
    	y: 5 + tileSize / 2 - 16
    });
    var confirmButton = uiArea.append('g').attr({
    	id: 'confirm-button',
    	cursor: 'pointer',
    	visibility: 'hidden'
    }).on('click', function() {
    	d3.selectAll('#confirm-button,#active-tile-rotation-indicator').attr('visibility', 'hidden');
    	d3.select('#send-move-button').attr({
    		visibility: null,
    		opacity: 1
		});
		d3.select('#meeple-placements').attr('visibility', null);
    });
    confirmButton.append('circle').attr({
    	cy: 5 + tileSize / 2,
    	cx: $('#svg-wrapper').width() - 5 - tileSize / 2,
    	r: 30,
    	fill: 'green',
    	stroke: 'black',
    	'stroke-width': 5
    });
    confirmButton.append('use').attr({
    	'xlink:href': '#svgicon-selecting-from-list',
    	x: $('#svg-wrapper').width() - 5 - tileSize / 2 - 16,
    	y: 5 + tileSize / 2 - 16
    });
    
	function addNewGameListing(game, menuGroup) {
		var gameID = game._id;
		var element = '<div class="menu-game-listing" id="game-' + gameID + '">';
		// add remaining tiles text
		element += '<span class="right-side"><span class="tile-count">[' + (game.unusedTiles.length + (game.finished ? 0 : 1)) + ']</span><i class="fa fa-trash-o hidden"></i></span>';
		// add sub divs for each user in the game
		element += game.players.map(function(item) {
   			return '<div class="game-player-listing">' + (item.active ? '&lt;' + item.user.username+ '&gt;' : item.user.username) + '</div>';
 		}).join('');
 		element += '</div>';
 		// when the game listing is clicked load that game
   		$(element).click(function() {
     	  	socket.emit('load game', gameID);
     	  	$('#chat-wrapper').removeClass('hidden');
     	  	currentGameID = gameID;
		}).appendTo(menuGroup);
	    // show the game delete/edit button in case it was hidden
    	$('#game-menu .fa-edit').removeClass('hidden');
	}
	
    // draw the menus
    var $gameListings = $('#game-menu');
    var $activeGames = $('#active-games');
    var $inactiveGames = $('#inactive-games');
    var $finishedGames = $('#finished-games');
    // add the active games and separate waiting and finished games
    for(var i = 0; i < userGames.length; i++) {
    	if(userGames[i].finished) {
		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
		   		$('#game-' + userGames[i]._id).appendTo($finishedGames);
		   	} else {
		   		addNewGameListing(userGames[i], $finishedGames);
		   	}
    	} else {
        	var active = false;
        	for(var k = 0; k < userGames[i].players.length; k++) {
        		if(userGames[i].players[k].user._id === userID &&
        		   userGames[i].players[k].active) {
        		   	active = true;
        		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
        		   		$('#game-' + userGames[i]._id).appendTo($activeGames);
        		   	} else {
		   				addNewGameListing(userGames[i], $activeGames);
        		   	}
        			break;
        		}
        	}
        	if(!active) {
    		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
    		   		$('#game-' + userGames[i]._id).appendTo($inactiveGames);
    		   	} else {
		   				addNewGameListing(userGames[i], $inactiveGames);
    		   	}
        	}
    	}
    }
    // set up the friends menu
    var friends = userFriends.sort(function(a, b) {
    	var username_a = a.username.toLowerCase();
    	var username_b = b.username.toLowerCase();
    	if(username_a  > username_b) {
    		return 1;
    	}
    	if(username_a < username_b) {
    		return -1;
    	}
    	return 0;
    });
    var $friendsList = $('#friends-menu');
    // show the friends edit button if there are friends to potentially delete
    if(friends.length > 0) {
    	$friendsList.find('.fa-edit').removeClass('hidden');
    }
    for(var j = 0; j < friends.length; j++) {
    	if($friendsList.has('#friend-' + friends[j]._id).length === 0) {
    		// insert the new friend in alphabetical order by display name
    		var element = '<div class="friend-listing" id="friend-' + friends[j]._id + '"><i class="fa fa-user"></i> ' + friends[j].username + '</div>';
    		if(j === 0) {
    			$(element).appendTo("#friends-list");
    		} else {
				$(element).insertAfter('#friend-' + friends[j-1]._id);
    		}
    	}
    }
    
    // reset the active tile if the user clicks the background and isn't doing a zoom/pan
    d3.select('#game-background').on('click', function() {
    	if (d3.event.defaultPrevented === false) {
    		resetActiveTile(true);
		}
	});
    // update the SVG on resize
    $(window).on("debouncedresize", function () { if(lastGamestate) { draw(lastGamestate); }});  
    // listen for new gamestate data from the server
    socket.on('sending gamestate', function(gamestate, loadingGame) {
    	// update the tile count in the menu
    	$('#game-' + gamestate._id + ' .tile-count').text('[' + (gamestate.unusedTiles.length + (gamestate.finished ? 0 : 1)) + ']');
    	// put the game listing in the correct place in the menu
        var $activeGames = $('#active-games');
        var $inactiveGames = $('#inactive-games');
        var $finishedGames = $('#finished-games');
        var $newGame = $('#game-' + gamestate._id);
        // mark the active players name with <username> in the game list
        var activePlayerIndex = 0;
        while(!gamestate.players[activePlayerIndex].active && activePlayerIndex < gamestate.players.length) {
        	activePlayerIndex++;
        }
        $newGame.children('.game-player-listing').text(function(i, text) {
        	var username = text.replace('<','').replace('>','');
        	return (i === activePlayerIndex ? '<' + username + '>' : username)
    	});
    	// put the game listing in the correct category in the menu
    	if(gamestate.finished) {
    		if($finishedGames.has($newGame).length === 0) {
	   			$newGame.appendTo($finishedGames);
    		}
    	} else {
        	var active = false;
        	for(var k = 0; k < gamestate.players.length; k++) {
        		if(gamestate.players[k].user._id === userID &&
        		   gamestate.players[k].active) {
        		   	active = true;
    				if($activeGames.has($newGame).length === 0) {
	    		   		$newGame.appendTo($activeGames);
    				}
        			break;
        		}
        	}
        	if(!active) {
				if($inactiveGames.has($newGame).length === 0) {
	   				$newGame.appendTo($inactiveGames);
				}
        	}
    	}
    	// update the page title to inform the user there is something new if it is their turn
    	if(gamestate.players[activePlayerIndex].user._id === userID) {
	    	document.title = '(!) Concarneau';
	    	$('body').on('mousemove', function() { 
				document.title = 'Concarneau';
				$('body').off('mousemove');
			});
    	}
    	// if this is the first time loading this game clear the chat list and redraw all messages
		if(loadingGame) {
			// draw chat messages into chat box grouped by username
			$('#chat-header-label span').text(' Chat');
			var $chatBody = $('#chat-body');
			var $messageList = $('#chat-message-list').detach();
			$messageList.empty();
			var index = 0;
			while(index < gamestate.messages.length) {
				var username = gamestate.messages[index].username;
				var messageGroup = [];
				while(messageGroup.length === 0 ||
				      (index < gamestate.messages.length && gamestate.messages[index].username === username)) {
					messageGroup.push(gamestate.messages[index].message);
					index++
				}
				// if there is no username this is a system generated message so don't draw a username and apply the system message class
				var $li = username === null ? $('<li>') : $('<li>').append($('<div class="chat-user-name">').text(username + ':'));
				for(var j = 0; j < messageGroup.length; j++) {
					$li.append($(username === null ? '<div class="chat-system-message">' : '<div class="chat-message">').text(messageGroup[j]));
				}
				$messageList.append($li);
			}
			$chatBody.append($messageList);
			// scroll chat messages to bottom
			$chatBody.scrollTop($chatBody[0].scrollHeight);
			$('#chat-footer input').val('');
     	  	$('#chat-wrapper').removeClass('hidden');
		} else if (gamestate.messages &&
		           gamestate.messages.length > 0 &&
		           gamestate.messages[gamestate.messages.length - 1].username === null) {
			// if not the first time loading this game draw any new messages from the server
			var lastServerMessage = $('#chat-message-list .chat-system-message').last().text();
			var i = gamestate.messages.length - 1;
			var newMessages = [];
			while(i >= 0 && gamestate.messages[i].username === null && gamestate.messages[i].message !== lastServerMessage) {
				newMessages.unshift(gamestate.messages[i].message);
				i--;
			}
			for(var k = 0; k < newMessages.length; k++) {
				addMessageToChat(newMessages[k], null);
			}
		}
		// only draw if we are loading or are currently viewing this game 
		if(currentGameID === gamestate._id) {
			draw(gamestate);
		}
	});
	socket.on('game started', function(gamestate, startingUserID) {
		// add to active or inactive games depending on which this player is
        var $activeGames = $('#active-games');
        var $inactiveGames = $('#inactive-games');
    	var active = false;
    	for(var k = 0; k < gamestate.players.length; k++) {
    		if(gamestate.players[k].user._id === userID &&
    		   gamestate.players[k].active) {
    		   	active = true;
   				addNewGameListing(gamestate, $activeGames);
    			break;
    		}
    	}
    	if(!active) {
   			addNewGameListing(gamestate, $inactiveGames);
    	}
    	// get the index of the active player
        var activePlayerIndex = 0;
        while(!gamestate.players[activePlayerIndex].active && activePlayerIndex < gamestate.players.length) {
        	activePlayerIndex++;
        }
		// draw if this user triggered the new game
		// if it is the players turn update the page title to inform the user there is a game to play a move in
		if(userID === startingUserID) {
			$('#chat-header-label span').text(' Chat');
			$('#chat-message-list').empty();
     	  	$('#chat-wrapper').removeClass('hidden');
			currentGameID = gamestate._id;
			draw(gamestate);
		} else if(gamestate.players[activePlayerIndex].user._id === userID) {
	    	document.title = '(!) Concarneau';
	    	$('body').on('mousemove', function() { 
				document.title = 'Concarneau';
				$('body').off('mousemove');
			});
		}
	});
	socket.on('friend added', function(username, userID) {
		// found a user with this username, add to the friends list in the menu and flash a success message
		var $alert = $('#username-alert');
		$alert.text('Added!');
		$alert.removeClass('alert-danger').addClass('alert-success').fadeTo(0, 1).fadeTo(3500, 0);
		// insert into the friends list alphabetically
		var element = '<div class="friend-listing" id="friend-' + userID + '"><i class="fa fa-user"></i> ' + username + '</div>';
		var $listings = $('.friend-listing');
		if($listings.length === 0) {
			$(element).appendTo('#friends-list');
		} else {
			$listings.each(function(index) {
				if($listings.length <= index + 1 ||
				   $($listings[index+1]).text().trim() > username) {
					$(element).insertAfter(this);
					return false;
				}
			});
		}
		// make sure the edit button is shown
		$('#friends-menu .fa-edit').removeClass('hidden');
	});
	socket.on('friend not found', function() {
		// couldn't find a user with this username, flash an error message
		var $alert = $('#username-alert');
		$alert.text('Username not found!');
		$alert.removeClass('alert-success').addClass('alert-danger').fadeTo(0, 1).fadeTo(3500, 0);
	});
	socket.on('message sent', function(message, username, gameID) {
		// add any received messages for the current game to the chatbox
		if(gameID === currentGameID) {
			addMessageToChat(message, username);
		}
	});
	
	function addMessageToChat(message, username) {
		var $chatBody = $('#chat-body');
		var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
		// add the message either to the username group if it hasn't changed (and the last message was a chat not a system message) or create a new one
		if(username !== null &&
		   $chatBody.find('.chat-user-name').last().text() === username + ':' && 
		   $chatBody.find('div').last().hasClass('chat-message')) {
			$('#chat-message-list li').last().append($('<div class="chat-message">').text(message));
		} else if(username !== null) {
			$('#chat-message-list').append(
				$('<li>').append(
					$('<div class="chat-user-name">').text(username + ':')
				).append(
					$('<div class="chat-message">').text(message)
				)
			);
		} else {
			$('#chat-message-list').append(
				$('<li>').append(
					$('<div class="chat-system-message">').text(message)
				)
			);
		}
		// scroll the chat list down if the user was already at the bottom of it
		// otherwise inform of the new message until they scroll down
		if(scrolledToBottom && !$chatBody.is(':hidden')) {
			$chatBody.scrollTop($chatBody[0].scrollHeight);
		} else {
			$('#chat-header-label span').text(' Chat (!)');
			$('#chat-toggle a').on('click.update-header', function() {
				$('#chat-header-label span').text(' Chat');
				$(this).off('click.update-header');
			})
			$chatBody.bind('scroll', function(e) {
				var $chatBody = $(e.currentTarget);
				var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
				if(scrolledToBottom) {
					$('#chat-header-label span').text(' Chat');
					$chatBody.off('scroll');
				}
			});
		}
	}
    
    function draw(gamestate) {
        svgHeight = $('#svg-wrapper').height();
        svgWidth = $('#svg-wrapper').width();
        // if this SVG isn't visible don't update it
        if (svgWidth === 0 || svgHeight === 0) {
            return;
        }
        
    	lastGamestate = gamestate;
    	
    	// position the buttons under the active tile image in the upper right
    	d3.selectAll('#confirm-button > circle,#send-move-button > circle').attr({
    		cx: svgWidth - 5 - tileSize / 2
    	});
    	d3.selectAll('#confirm-button > use,#send-move-button > use').attr({
    		x: svgWidth - 5 - tileSize / 2 - 16
    	});
    	
    	resetActiveTile(false);
    	
		// rotate the player array such that this player is on top
		// go through the entire array to ensure that if this player is in the game multiple times the active version is on top
		var playerCount = gamestate.players.length;
		var count = 0;
    	var reorderedPlayers = gamestate.players.slice(0);
		while(reorderedPlayers[0].user._id !== userID ||
		      (!reorderedPlayers[0].active && count < playerCount)) {
	      	count++;
			reorderedPlayers.push(reorderedPlayers.shift());
		}
		// get the number of remaining meeples and the color
		var meepleColor = reorderedPlayers[0].color;
		var remainingMeeples = reorderedPlayers[0].remainingMeeples;
		var userIsActive = reorderedPlayers[0].active;
    	
        // for all newly placed tiles add a group for the placed tile and its meeples
        var tileGroup = placedTiles.selectAll('g.placed-tile').data(gamestate.placedTiles);
        tileGroup.enter().append('g').attr({
        	class: 'placed-tile'
    	}).append('image').attr({
    		class: 'tile-image',
            x: 0,
            y: 0,
            width: tileSize,
            height: tileSize
        });
        tileGroup.attr({
        	transform: function(d) { 
        		var x = svgWidth / 2 + d.x * tileSize;
        		var y = svgHeight / 2 + d.y * tileSize;
        		return 'rotate(' + 90 * d.rotation + ',' + (x + tileSize / 2) + ',' + (y + tileSize / 2) + ') translate(' + x + ',' + y + ')';
    		}
        });
        // then draw the tile image
        placedTiles.selectAll('image.tile-image').data(gamestate.placedTiles).attr({
            'xlink:href': function(d) { return d.tile.imageURL; }
        });
        tileGroup.exit().remove();
        // then draw the meeples placed on the tiles
        var meepleImages = tileGroup.selectAll('image.meeple').data(function(d) {
    		return d.meeples.map(function(item) { 
        		return {
        			color: gamestate.players[item.playerIndex].color,
        			rotation: d.rotation,
        			location: item.placement.locationType,
        			large: item.large,
        			meepleOffset:
            			item.placement.locationType === 'cloister' ? 
	            			{ x: 1/2, y: 1/2 } :
	            		item.placement.locationType === 'city' ?
	            			d.tile['cities'][item.placement.index].meepleOffset :
	            			d.tile[item.placement.locationType + 's'][item.placement.index].meepleOffset
        		};
    		});
    	});
    	// adding any new meeples
    	meepleImages.enter().append('image').attr({ 
    		class: 'meeple',
			width: function(d) { return d.large ? tileSize * 3 / 8 : tileSize / 4 },
			height: function(d) { return d.large ? tileSize * 3 / 8 : tileSize / 4; }
		});
    	meepleImages.attr({
        	x: function(d) { return tileSize * d.meepleOffset.x - (d.large ? tileSize * 3 / 8 : tileSize / 4) / 2; },
			y: function(d) { return tileSize * d.meepleOffset.y - (d.large ? tileSize * 3 / 8 : tileSize / 4) / 2; },
			'xlink:href': function(d) { 
				return '/content/images/meeples/' + d.color + '_' + (d.location === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			transform: function(d) { 
				return 'rotate(' + d.rotation * -90 + ',' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')'; 
			}
        });
        // and removing any meeples that have been picked up
        meepleImages.exit().remove();
        
    	// draw the active tile
    	var activeTileImage = activeTileImageContainer.selectAll('#active-tile-image').data(gamestate.activeTile.tile ? [gamestate.activeTile.tile] : []);
        activeTileImage.enter().insert('image', '#active-tile-rotation-indicator').attr({
            width: tileSize,
            height: tileSize,
            id: 'active-tile-image',
            'pointer-events': 'none'
        });
        // reset to the base position and update the image URL every draw
        activeTileImage.attr({
			x: -tileSize / 2,
			y: -tileSize / 2,
            'xlink:href': function(d) { return d.imageURL; }
        });
        activeTileImage.exit().remove();
		//TODO: show discarded tiles being tossed
		
		// draw the places where the active tile can be placed
		var validPlacements = placements.selectAll('image.tile-placements').data(userIsActive ? gamestate.activeTile.validPlacements : []);
		validPlacements.enter().append('image').attr({
			class: 'tile-placements',
			id: function(d, i) { return 'placement-' + i; },
            width: tileSize,
            height: tileSize,
            'xlink:href': '/content/images/ui/placement_available.png'
		});
		// transition all to visible overwriting the previous fade transition
		validPlacements.transition().attr({ opacity: 1 });
		validPlacements.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
            y: function(d) { return svgHeight / 2 + d.y * tileSize; }
		}).on('click', function (d, i) {
			var $activeTile = $('#active-tile');
			var rotationIndex;
			// if we have previously clicked this placement box move to the next valid rotation
			if($activeTile.data('placementIndex') === i) {
				rotationIndex = ($activeTile.data('rotationIndex') + 1) % d.rotations.length;
			} else {
				// if this is a new location reset to the first rotation
				rotationIndex = 0;
				// show all the remaining meeples in case one was temporarily placed and is returned to the pool
				$('#score-area image').removeAttr('visibility');
				// reset the move
				selectedMove = { 
					placement: gamestate.activeTile.validPlacements[i]
				};
				// and reset the large meeple mode if it was set
				disableLargeMeeple();
				// show the placement confirmation again and hide the send move button, meeple outlines, and any placed meeples
				d3.selectAll('#meeple-placements,#send-move-button,#meeple-placements .placed-meeple').attr('visibility', 'hidden');
				d3.selectAll('#confirm-button').attr('visibility', null);
				d3.selectAll('#confirm-button').transition().duration(transitionDuration).attr('opacity', 1);
			}
			selectedMove.rotation = d.rotations[rotationIndex].rotation;
			var rotationDegrees = selectedMove.rotation * 90;
			// store data about this selection in the active tile
			$activeTile.data('rotationIndex', rotationIndex);
			$activeTile.data('placementIndex', i);
			// move the active tile over top of the placement box
			var x = parseInt($(this).attr('x'), 10);
			var y = parseInt($(this).attr('y'), 10);
			d3.select('#active-tile').transition().duration(transitionDuration).attr({
				transform: 'translate(' + x + ',' + y + ')'
			});
			d3.select('#active-tile-rotation').transition().duration(transitionDuration).attr({
				transform: 'rotate(' + rotationDegrees + ')'
			});
			// if there are rotations make the indicator visible
			d3.select('#active-tile-rotation-indicator').transition().duration(transitionDuration).attr({
				opacity: d.rotations.length > 1 ? 0.45 : 0,
				visibility: null
			});
			if(remainingMeeples > 0) {
				// show outlines for any valid meeple placements and
    			// rotate the meeple placeholders and hidden placed meeples to upright positions
				var validMeeplePlacements = d.rotations[rotationIndex].meeples;
				var container = d3.select('#meeple-placements');
				container.selectAll('image.meeple-outline').transition().duration(transitionDuration).attr({
					visibility: function(d) {
						for(var i = 0; i < validMeeplePlacements.length; i++) {
							if(validMeeplePlacements[i].locationType === d.type &&
							   validMeeplePlacements[i].index === d.index) {
								// remove hidden visibility attribute
								return null;
							}
						}
						return 'hidden';
					},
					transform: function() { 
						return 'rotate(' + -rotationDegrees + ')';
					}
				});
				// remove meeple placement from the move and hide placed meeple if old placement is no longer valid
				container.selectAll('image.placed-meeple').transition().duration(transitionDuration).attr({
					visibility: function(d) {
						for(var i = 0; i < validMeeplePlacements.length; i++) {
							if(validMeeplePlacements[i].locationType === d.type &&
							   validMeeplePlacements[i].index === d.index) {
								// remove hidden visibility attribute
								return $(this).attr('visibility');
							}
						}
						if(selectedMove.meeple &&
						   selectedMove.meeple.type === d.type &&
						   selectedMove.meeple.index === d.index) {
							$('#score-area image').first().removeAttr('visibility');
							delete selectedMove.meeple;
						}
						return 'hidden';
					},
					transform: function() { 
						return 'rotate(' + -rotationDegrees + ')';
					}
				});
			}
		});
		validPlacements.exit().remove();
			
		// draw the potential meeple placement for the active tile
		var allMeepleLocations = [];
		if(gamestate.activeTile.tile) {
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.roads.map(function(item, index) { item.type = 'road'; item.index = index; return item; }));
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.farms.map(function(item, index) { item.type = 'farm'; item.index = index; return item; }));
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.cities.map(function(item, index) { item.type = 'city'; item.index = index; return item; }));
			if(gamestate.activeTile.tile.cloister) {
				allMeepleLocations = allMeepleLocations.concat([{ type: 'cloister', index: 1, meepleOffset: { x: 1/2, y: 1/2 }}]);
			}
		}
		// if there were none of a certain type remove all undefined elements added to the array
		allMeepleLocations = allMeepleLocations.filter(function(n) { return n !== undefined; });
		// don't display meeple locations if we can't place meeples
		if(remainingMeeples === 0 || !userIsActive) {
			allMeepleLocations = [];
		}
		// draw the outlines on which meeples can be placed
		var meepleOutlines = meeplePlacements.selectAll('g.outline-group').data(allMeepleLocations);
		var meepleGroup = meepleOutlines.enter().append('g').attr({
			class: 'outline-group'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'meeple-outline'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'placed-meeple'
		});
		meepleOutlines.attr({
			transform: function(d) {
				return 'translate(' + (d.meepleOffset.x - 1/2) * tileSize + ',' + (d.meepleOffset.y - 1/2) * tileSize + ')';
			}
		});
		meepleOutlines.select('image.meeple-outline').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) {
				return '/content/images/meeples/outline_' + (d.type === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// when an outline is clicked grab the leftmost available meeple and move it onto the outline
			var $placedMeeples = $('.placed-meeple');
			$placedMeeples.attr('visibility', 'hidden');
			$(this).siblings('.placed-meeple').first().removeAttr('visibility');
			if(usingLargeMeeple) {
				$('#score-group-' + meepleColor + ' image.remaining-large-meeple').first().attr('visibility', 'hidden');
			} else {
				$('#score-group-' + meepleColor + ' image.remaining-meeple').first().attr('visibility', 'hidden');
			}
			selectedMove.meeple = {
				type: d.type,
				index: d.index,
				large: usingLargeMeeple
			};
		});
		meepleOutlines.select('image.placed-meeple').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) { 
				return '/content/images/meeples/' + meepleColor + '_' + (d.type === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// when a visible meeple is clicked hide it and remove it from the move
			$(this).attr('visibility', 'hidden');
			$('#score-group-' + meepleColor + ' image').first().removeAttr('visibility');
			delete selectedMove.meeple;
		});
		meepleOutlines.exit().remove();

		// draw outlines indicating the last tile each player placed
		var markers = [];
		// first find the index of the active player
		var index = 0;
		while(gamestate.players[index].active !== undefined && !gamestate.players[index].active) {
			index++;
		}
		// for each tile placed assign x and y of the tile and move backwards through the players to assign color
		for(var k = 1; k <= Math.min(gamestate.players.length, gamestate.placedTiles.length - 1); k++) {
			if(gamestate.placedTiles.length - k > 0) {
				markers.push({
					x: gamestate.placedTiles[gamestate.placedTiles.length - k].x,
					y: gamestate.placedTiles[gamestate.placedTiles.length - k].y,
					color: gamestate.players[(index - k + gamestate.players.length) % gamestate.players.length].color
				});
			}
		}
		
		var turnMarkers = turnMarkerArea.selectAll('rect.turn-marker').data(markers);
		turnMarkers.enter().append('rect').attr({
			class: 'turn-marker',
			'fill-opacity': 0,
			'stroke-width': 4,
			'stroke-linejoin': 'round',
			rx: 7,
			ry: 7,
			width: tileSize,
			height: tileSize
		});
		turnMarkers.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
			y: function(d) { return svgHeight / 2 + d.y * tileSize; },
			stroke: function(d) { return d.color; }
		});
		turnMarkers.exit().remove();
		
		// draw the players scores and remaining meeples
		// resize the score background to be sized to include (or not) the large meeple from Inns and Cathedrals
		var bgWidth = 15 + 7*(tileSize / 4.75) + 15;
		if(gamestate.expansions.indexOf('inns-and-cathedrals') !== -1) {
			bgWidth += tileSize * 3 / 8 - 5;
		}
		scoreArea.select('#score-bg').attr({
			height: tileSize / 4 + reorderedPlayers.length*(tileSize / 2 - 5),
			width: bgWidth,
			opacity: .75
		});
		var scoreGroups = scoreArea.selectAll('g.score-group').data(reorderedPlayers);
		var group = scoreGroups.enter().append('g').attr({
			class: 'score-group'
		});
		scoreGroups.attr({
			id: function(d) {
				return 'score-group-' + d.color;
			}
		});
		group.append('text').attr({
			class: 'point-total',
			x: 5 + 7*(tileSize / 4.75),
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'end'
		});
		group.append('text').attr({
			class: 'player-name-outline',
			x: 5,
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'start',
			stroke: 'black',
			'stroke-width': 2.5
		});
		group.append('text').attr({
			class: 'player-name',
			x: 5,
			y: function(d, i) {
				return 5 + tileSize / 8 + i*(tileSize / 2 - 5);
			},
			'text-anchor': 'start'
		});
		scoreGroups.select('text.point-total').text(function(d) { return d.points; });
		scoreGroups.select('text.player-name-outline').text(function (d) { return d.user.username; });
		scoreGroups.select('text.player-name').attr({ 
			fill: function(d) {
				if(d.color === 'purple') {
					return 'fuchsia';
				} else if (d.color === 'blue') {
					return 'royalblue';
				}
				return d.color;
			}
		}).text(function (d) { return d.user.username; });
		scoreGroups.exit().remove();
		
		//TODO: have the active player placed meeple move down from the remaining meeples onto the tile
		var availableMeeples = scoreGroups.selectAll('image.remaining-meeple').data(function(d, i) { 
			var array = [];
			for(var k = 0; k < d.remainingMeeples; k++) {
				array.push({
					x: 5 + k*(tileSize / 4.75),
					y: tileSize / 4 - 5 + i*(tileSize / 2 - 5),
					url: '/content/images/meeples/' + d.color + '_standing.png'
				});
			}
			array.reverse();
			return array;
		});
		availableMeeples.enter().append('image').attr({
			class: 'remaining-meeple',
			y: function(d) { return d.y; },
			width: tileSize / 4,
			height: tileSize / 4
		});
		availableMeeples.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		availableMeeples.exit().remove();
		
		var availableLargeMeeple = scoreGroups.selectAll('image.remaining-large-meeple').data(function(d, i) {
			if(d.hasLargeMeeple) {
				return [{ 
					x: 5 + 7*(tileSize / 4.75),
					y: i*(tileSize / 2 - 5) + tileSize / 14,
					url: '/content/images/meeples/' + d.color + '_standing.png'
				}];
			}
			return [];
		});
		availableLargeMeeple.enter().append('image').attr({
			class: 'remaining-large-meeple',
			y: function(d) { return d.y; },
			width: tileSize * 3 / 8,
			height: tileSize * 3 / 8,
			cursor: function(d, i) { 
				return i === 0 ? 'pointer' : null; 
			}
		}).on('click', function(d, i) {
			// if the first meeple is clicked move into large meeple placement mode
			if(i === 0) { 
				enableLargeMeeple();
			}
		});
		availableLargeMeeple.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		availableLargeMeeple.exit().remove();
    
	    // if there are no normal meeples remaining but there is a large meeple activate large meeple placement mode
    	var activeScoreGroup = $('.score-group').first();
	    if(activeScoreGroup.find('.remaining-meeple').length === 0 && activeScoreGroup.find('.remaining-large-meeple').length === 1) {
			enableLargeMeeple();
	    }
	    //TODO: show unused tile count, clickable to show remaining tile counts
    }
});
</script>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-50702481-1', 'concarneau.herokuapp.com');
  ga('send', 'pageview');
</script>
</body>
</html>
