<!doctype html>
<html>
<head>
    <script type="text/javascript">
    // if Facebook redirect hash is present remove it: https://stackoverflow.com/questions/7131909/facebook-callback-appends-to-return-url
    if (window.location.hash && window.location.hash == '#_=_') {
        if (window.history && history.pushState) {
            window.history.pushState("", document.title, window.location.pathname);
        } else {
            window.location.hash = '';
        }
    }
	</script>
    <title>Concarneau</title>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css">
    <style>
    	body 		{ padding-top:80px; }
    </style>
</head>
<body>
<div class="container">
	<div class="page-header text-center">
		<h1>Games</h1>
		<a href="/logout" class="btn btn-default btn-sm">Logout</a>
	</div>
	<div>
		<div><span>Your user ID: <%= user._id %></span></div>
		<div><span>Your friends' IDs: <%= user.friends.join(', ') %></span></div>
		<h3>Active games:</h3>
		<ul id="active-game-list">
			<% for (var i = 0; i < user.activeGames.length; i++) { %>
			<li onclick="socket.emit('load game', '<%= user.activeGames[i]._id %>')"><%= user.activeGames[i].name + ' (id: ' + user.activeGames[i]._id + ') ' + user.activeGames[i].placedTiles.length + ' tiles placed' %></li>
			<% } %>
		</ul>
		<div class="col-lg-4">
			<button class="btn btn-default btn-sm" onclick="socket.emit('new game')">New game</button>
			<button class="btn btn-default btn-sm" onclick="socket.emit('start game', currentGameID)">Start game</button>
			<button class="btn btn-default btn-sm" onclick="$(this).prop('disabled', true); socket.emit('sending move', currentGameID, selectedMove);" disabled="true" id="send-move-button">Send move</button>
			<div class="input-group">
				<input type="text" class="form-control" placeholder="User ID" id="change-name-input">
				<span class="input-group-btn">
					<button class="btn btn-default" type="button" onclick="socket.emit('set display name', $('#change-name-input').val())">Change display name</button>
				</span>
			</div>
			<div class="input-group">
				<input type="text" class="form-control" placeholder="User ID" id="add-friend-input">
				<span class="input-group-btn">
					<button class="btn btn-default" type="button" onclick="socket.emit('add friend', $('#add-friend-input').val())">Add friend</button>
				</span>
			</div>
			<div class="input-group">
				<input type="text" class="form-control" placeholder="User ID" id="remove-friend-input">
				<span class="input-group-btn">
					<button class="btn btn-default" type="button" onclick="socket.emit('remove friend', $('#remove-friend-input').val())">Remove friend</button>
				</span>
			</div>
			<div class="input-group">
				<input type="text" class="form-control" placeholder="User ID" id="add-to-game-input">
				<span class="input-group-btn">
					<button class="btn btn-default" type="button" onclick="socket.emit('add user to game', currentGameID, $('#add-to-game-input').val())">Add to game</button>
				</span>
			</div>
		</div>
	</div>
	<svg id="game-svg" width="1000" height="600">
	<rect x="0" y="0" width="1000" height="600" fill="lightblue" id="game-background"></rect>
	</svg>
	<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js"></script>
	<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.5/d3.min.js"></script>
	<script>
	//TODO: show active players + points + remaining meeples
	//TODO: make better background
	//TODO: integrate friends list into side panel on SVG
	//TODO: integrate game list into side panel on SVG
	//TODO: have first game autoload
	//TODO: move send game button onto SVG
	//TODO: move name change onto SVG side panel
	//TODO: make game creation dialog where user can select friends before game starts
	//TODO: auto calculate zoom by number of tiles placed
	//TODO: add link accounts page link
	
	//TODO: move these variables out of the global namespace
	var socket = io.connect('https://concarneau-c9-btouellette.c9.io');
    var currentGameID, selectedMove, activeTileTransform;
    	
	function resetActiveTile() {
		$('#active-tile').removeData('rotationIndex').removeData('placementIndex').attr({ 
			transform: activeTileTransform
		});
		// hide any placed meeples and their outlines and remove any selected move
		$('#meeple-placements image').attr('visibility', 'hidden');
		selectedMove = null;
		$('#send-move-button').prop('disabled', true);
	}
	$(document).ready(function() {
        var tileSize = 100;
		
        var zoom = d3.behavior.zoom().scaleExtent([0.25, 1]).on('zoom', function() {
    		d3.event.sourceEvent.preventDefault();
			gameArea.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
			activeTileTransform = 'scale(' + 1/d3.event.scale + ') translate(' + d3.event.translate.map(function(item) { return -1 * item + 5; }) + ')';
			if(!selectedMove) {
				activeTileContainer.attr('transform', activeTileTransform);
			}
		});
		//TODO: zoom and pan when active tile moves if out of zoom/pan range
		//TODO: use d3 transitions
		
        var svg = d3.select('#game-svg').call(zoom);
        var svgHeight = $('#game-svg').height();
        var svgWidth = $('#game-svg').width();
        
		var gameArea = svg.append('g').attr({ id: 'game-area' });
        var placedTiles = gameArea.append('g').attr({ id: 'placed-tiles' });
		var placements = gameArea.append('g').attr({ id: 'valid-placements' });
        var activeTileContainer = gameArea.append('g').attr({ id: 'active-tile', transform: 'translate(5,5)' });
        var meeplePlacements = activeTileContainer.append('g').attr({ id: 'meeple-placements' });
        
        // reset the active tile if the user clicks the background and isn't doing a zoom/pan
        d3.select('#game-background').on('click', function() {
        	if (d3.event.defaultPrevented === false) {
        		resetActiveTile();
    		}
		});
        
        socket.on('sending gamestate', function(gamestate) {
        	console.log('==== got gamestate ====');
        	console.log(JSON.stringify(gamestate));
        	currentGameID = gamestate._id;
        	draw(gamestate);
    	});

        function draw(gamestate) {
        	resetActiveTile();
            // for all newly placed tiles: add a group for the placed tile and its meeples
            // then draw the tile image
            var tileGroup = placedTiles.selectAll('g.placed-tile').data(gamestate.placedTiles);
            tileGroup.enter().append('g').attr({
            	class: 'placed-tile',
            	transform: function(d) { 
            		var x = svgWidth / 2 + d.x * tileSize;
            		var y = svgHeight / 2 + d.y * tileSize;
            		return 'rotate(' + 90 * d.rotation + ',' + (x + tileSize / 2) + ',' + (y + tileSize / 2) + ') translate(' + x + ',' + y + ')';
        		}
        	}).append('image').attr({
                x: function(d) { return 0; },
                y: function(d) { return 0; },
                width: tileSize,
                height: tileSize,
                'xlink:href': function(d) { return d.tile.imageURL; }
            });
            // then draw the meeples placed on all tiles
            var meepleImages = tileGroup.selectAll('image.meeple').data(function(d) {
        		return d.meeples.map(function(item) { 
            		return {
            			color: gamestate.players[item.playerIndex].color,
            			rotation: d.rotation,
            			location: item.placement.locationType,
            			meepleOffset:
	            			item.placement.locationType === 'cloister' ? 
		            			{ x: 1/2, y: 1/2 } :
		            		item.placement.locationType === 'city' ?
		            			d.tile['cities'][item.placement.index].meepleOffset :
		            			d.tile[item.placement.locationType + 's'][item.placement.index].meepleOffset
            		};
        		});;
        	});
        	// adding any new meeples
        	meepleImages.enter().append('image').attr({
            	class: 'meeple',
            	x: function(d) { return (d.meepleOffset.x - 1/8) * tileSize; },
				y: function(d) { return (d.meepleOffset.y - 1/8) * tileSize; },
				width: tileSize / 4,
				height: tileSize / 4,
				'xlink:href': function(d) { 
					return '/images/meeples/' + d.color + '_' + (d.location === 'farm' ? 'lying' : 'standing') +'.png'; 
				},
				transform: function(d) { 
					return 'rotate(' + d.rotation * -90 + ',' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')'; 
				}
            });
            // and removing any meeples that have been picked up
            meepleImages.exit().remove();
            
        	// draw the active tile
        	var activeTileImage = activeTileContainer.selectAll('image').data(gamestate.activeTile.tile ? [gamestate.activeTile.tile] : []);
            activeTileImage.enter().insert('image', '#meeple-placements').attr({
                width: tileSize,
                height: tileSize,
                'pointer-events': 'none'
            });
            // reset to the base position and update the image URL every draw
            activeTileImage.attr({
				x: 0,
				y: 0,
                'xlink:href': function(d) { return d.imageURL; }
            });
			//TODO: show discarded tiles being tossed
			
			// get the number of remaining meeples and the color
			var meepleColor, remainingMeeples;
			for(var i = 0; i < gamestate.players.length; i++) {
				if(gamestate.players[i].user === '<%= user._id %>') {
					meepleColor = gamestate.players[i].color;
					remainingMeeples = gamestate.players[i].remainingMeeples;
				}
			}
			// draw the places where the active tile can be placed
			var validPlacements = placements.selectAll('image').data(gamestate.activeTile.validPlacements);
			validPlacements.enter().append('image').attr({
				id: function(d, i) { return 'placement-' + i; },
                width: tileSize,
                height: tileSize,
                'xlink:href': '/images/ui/placement_available.png'
			});
			validPlacements.attr({
				x: function(d) { return svgWidth / 2 + d.x * tileSize; },
                y: function(d) { return svgHeight / 2 + d.y * tileSize; }
			}).on('click', function (d, i) {
				var $activeTile = $('#active-tile');
				var rotationIndex;
				// if we have previously clicked this placement box move to the next valid rotation
				if($activeTile.data('placementIndex') === i) {
					rotationIndex = ($activeTile.data('rotationIndex') + 1) % d.rotations.length;
				} else {
					// if this is a new location reset to the first rotation
					rotationIndex = 0;
					// hide any placed meeples
					$('#meeple-placements .placed-meeple').attr('visibility', 'hidden');
					// and reset the move
					selectedMove = { 
						placement: gamestate.activeTile.validPlacements[i]
					};
					$('#send-move-button').prop('disabled', false);
				}
				selectedMove.rotation = d.rotations[rotationIndex].rotation;
				var rotationDegrees = selectedMove.rotation * 90;
				// store data about this selection in the active tile
				$activeTile.data('rotationIndex', rotationIndex);
				$activeTile.data('placementIndex', i);
				// move the active tile over top of the placement box
				var x = parseInt($(this).attr('x'), 10);
				var y = parseInt($(this).attr('y'), 10);
				$activeTile.attr({
					transform: 'translate(' + x + ',' + y + ') rotate(' + rotationDegrees + ',' + tileSize / 2 + ',' + tileSize / 2 + ')'
				});
				if(remainingMeeples > 0) {
					// show outlines for any valid meeple placements and
        			// rotate the meeple placeholders and hidden placed meeples to upright positions
					var validMeeplePlacements = d.rotations[rotationIndex].meeples;
					var container = d3.select('#meeple-placements');
					container.selectAll('.meeple-outline').attr({
						visibility: function(d) {
							for(var i = 0; i < validMeeplePlacements.length; i++) {
								if(validMeeplePlacements[i].locationType === d.type &&
								   validMeeplePlacements[i].index === d.index) {
									// remove hidden visibility attribute
									return null;
								}
							}
							return 'hidden';
						},
						transform: function() { 
							return $(this).attr('transform').replace(/(rotate\()(\d+)/, '$1' + (360 - rotationDegrees));
						}
					});
					// remove meeple placement from the move and hide placed meeple if old placement is no longer valid
					container.selectAll('.placed-meeple').attr({
						visibility: function(d) {
							for(var i = 0; i < validMeeplePlacements.length; i++) {
								if(validMeeplePlacements[i].locationType === d.type &&
								   validMeeplePlacements[i].index === d.index) {
									// remove hidden visibility attribute
									return $(this).attr('visibility');
								}
							}
							if(selectedMove.meeple &&
							   selectedMove.meeple.type === d.type &&
							   selectedMove.meeple.index === d.index) {
								delete selectedMove.meeple;
							}
							return 'hidden';
						},
						transform: function() { 
							return $(this).attr('transform').replace(/(rotate\()(\d+)/, '$1' + (360 - rotationDegrees));
						}
					});
				}
			});
			validPlacements.exit().remove();
				
			// draw the potential meeple placement for the active tile
			if(remainingMeeples > 0 && gamestate.activeTile.tile) {
				var allMeepleLocations = gamestate.activeTile.tile.roads.map(function(item, index) { item.type = 'road'; item.index = index; return item; });
				allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.farms.map(function(item, index) { item.type = 'farm'; item.index = index; return item; }));
				allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.cities.map(function(item, index) { item.type = 'city'; item.index = index; return item; }));
				if(gamestate.activeTile.tile.cloister) {
					allMeepleLocations = allMeepleLocations.concat([{ type: 'cloister', index: 1, directions: ['C'], meepleOffset: { x: 1/2, y: 1/2 }}]);
				}
				// if there were none of a certain type remove all undefined elements added to the array
				allMeepleLocations = allMeepleLocations.filter(function(n) { return n != undefined });
				// draw the outlines on which meeples can be placed
				var meepleOutlines = meeplePlacements.selectAll('image.meeple-outline').data(allMeepleLocations);
				meepleOutlines.enter().append('image').attr({
					width: tileSize / 4,
					height: tileSize / 4,
					class: 'meeple-outline'
				});
				meepleOutlines.attr({
					x: function(d) {
						return (d.meepleOffset.x - 1/8) * tileSize;
					},
					y: function(d) {
						return (d.meepleOffset.y - 1/8) * tileSize;
					},
					transform: function(d) { 
						return 'rotate(0,' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')'; 
					},
					'xlink:href': function(d) { 
						return '/images/meeples/outline_' + (d.type === 'farm' ? 'lying' : 'standing') +'.png'; 
					},
					visibility: 'hidden'
				}).on('click', function(d, i) {
					// when an outline is clicked unhide the meeple in it
					var $placedMeeples = $('#meeple-placements .placed-meeple');
					$placedMeeples.attr('visibility', 'hidden');
					$placedMeeples.eq(i).removeAttr('visibility');
					selectedMove.meeple = {
						type: d.type,
						index: d.index
					};
				});
				meepleOutlines.exit().remove();
				
				var placedMeeples = meeplePlacements.selectAll('image.placed-meeple').data(allMeepleLocations);
				placedMeeples.enter().append('image').attr({
					width: tileSize / 4,
					height: tileSize / 4,
					class: 'placed-meeple'
				});
				placedMeeples.attr({
					x: function(d) {
						return (d.meepleOffset.x - 1/8) * tileSize;
					},
					y: function(d) {
						return (d.meepleOffset.y - 1/8) * tileSize;
					},
					'xlink:href': function(d) { 
						return '/images/meeples/' + meepleColor + '_' + (d.directions[0].length > 1 ? 'lying' : 'standing') +'.png'; 
					},
					transform: function(d) { 
						return 'rotate(0,' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')'; 
					},
					visibility: 'hidden'
				}).on('click', function(d, i) {
					// when a visible meeple is clicked hide it and remove it from the move
					$(this).attr('visibility', 'hidden');
					delete selectedMove.meeple;
				});
				placedMeeples.exit().remove();
			}
        }	
	});
    </script>
</div>
</body>
</html>