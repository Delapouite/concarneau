<!doctype html>
<html>
<head>
    <script type="text/javascript">
    // if Facebook redirect hash is present remove it: https://stackoverflow.com/questions/7131909/facebook-callback-appends-to-return-url
    if (window.location.hash && window.location.hash == '#_=_') {
        if (window.history && history.pushState) {
            window.history.pushState("", document.title, window.location.pathname);
        } else {
            window.location.hash = '';
        }
    }
	</script>
    <title>Concarneau</title>
    <link rel="shortcut icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
	<link rel="icon" href="/content/images/ui/favicon.ico" type="image/x-icon">
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/bootstrap/3.0.2/css/bootstrap.min.css" type='text/css'>
    <link rel="stylesheet" href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.min.css" type='text/css'>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.css" type='text/css'>
    <link rel="stylesheet" href="/content/css/game.css" type='text/css'>
</head>
<body>
<div id="wrapper">
<div id="menus">
	<div id="game-menu">
		<span class="menu-header">GAMES <i class="fa fa-edit" onclick="enableGamesEdit(event)"> <i class="fa fa-plus-square-o"></i></i></span>
		<div id="active-games">
			<div class="menu-sub-header">Your move:</div>
		</div>
		<div id="inactive-games">
			<div class="menu-sub-header">Waiting on move:</div>
		</div>
		<div id="finished-games">
			<div class="menu-sub-header">Finished:</div>
		</div>
	</div>
	<div id="friends-menu">
		<span class="menu-header">FRIENDS <i class="fa fa-edit" onclick="enableFriendsEdit(event)"></i></span>
		<form id="add-friend-form">
			<div class="input-group">
				<input type="text" class="form-control" id="add-friend-input" placeholder="Username" autocomplete="off">
				<span class="input-group-btn">
					<button class="btn btn-default" type="submit">Add</button>
				</span>
			</div>
		</form>
		<div id="username-alert" class="alert">Placeholder text</div>
		<div id="friends-list"></div>
	</div>
	<div id="settings-menu">
		<span class="menu-header">SETTINGS</span>
		<a href="/profile">Profile</a>
		<a href="/logout">Logout</a>
	</div>
</div>
<div id="menu-selection">
	<div id="game-menu-selection" class="iconmelon" onclick="menuClick('#game-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-templates"></use>
		</svg>
	</div>
	<div id="friends-menu-selection" class="iconmelon" onclick="menuClick('#friends-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-environment"></use>
		</svg>
	</div>
	<div id="settings-menu-selection" class="iconmelon" onclick="menuClick('#settings-menu', this)">
		<svg viewBox="0 0 32 32">
			<use xlink:href="#svgicon-settings"></use>
		</svg>
	</div>
</div>
<div id="author-info">
	<div>
		Created by <span id="author-name">Brian Ouellette</span>
		<a href="http://github.com/btouellette/concarneau"><img height="25" width="25" src="/content/images/ui/github_logo.png" /></a>
	</div>
	<span>Buy me a beer?</span>
	<form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_top">
		<input type="hidden" name="cmd" value="_donations">
		<input type="hidden" name="business" value="btouellette@gmail.com">
		<input type="hidden" name="lc" value="US">
		<input type="hidden" name="item_name" value="Concarneau">
		<input type="hidden" name="no_note" value="0">
		<input type="hidden" name="currency_code" value="USD">
		<input type="hidden" name="bn" value="PP-DonationsBF:paypal-icon.png:NonHostedGuest">
		<input type="image" height="25" width="25" src="/content/images/ui/paypal_logo.png" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!">
	</form>
	<img id="btc-donate" height="25" width="25" src="/content/images/ui/bitcoin_logo.png" />
</div>
<div id="svg-wrapper">
	<svg id="game-svg" width="100%" height="100%">
		<defs>
			<pattern id="thin-stripes-pattern" width="5" height="5" patternUnits="userSpaceOnUse">
				<rect width="5" height="5" fill="#f5f5f5"></rect>
				<path d="M0 5L5 0ZM6 4L4 6ZM-1 1L1 -1Z" stroke="#e0e0e0"></path>
			</pattern>
		</defs>
		<rect width="100%" height="100%" fill="url(#thin-stripes-pattern)" id="game-background"></rect>
	</svg>
</div>
<div id="chat-wrapper" class="panel panel-primary hidden">
	<div id="chat-header" class="panel-heading">
		<div id="chat-header-label"><i class="fa fa-comments"></i><span> Chat</span></div>
        <div id="chat-toggle" class="btn-group">
            <a class="btn btn-default btn-xs" onclick="$('#chat-body,#chat-footer').toggle()">
                <i class="fa fa-chevron-down"></i>
            </a>
        </div>
    </div>
	<div id="chat-body">
		<ul id="chat-message-list">
		</ul>
	</div>
	<div id="chat-footer">
		<form id="chat-message-form">
			<div class="input-group">
				<input id="chat-message-input" type="text" class="form-control input-sm" maxlength="100" placeholder="Type your message here...">
				<span class="input-group-btn">
					<button class="btn btn-sm btn-info" type="submit">Send</button>
				</span>
			</div>
		</form>
	</div>
</div>
</div>
<script src="//cdnjs.cloudflare.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/socket.io/0.9.16/socket.io.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/d3/3.4.5/d3.min.js"></script>
<script src="//cdnjs.cloudflare.com/ajax/libs/qtip2/2.2.0/jquery.qtip.min.js"></script>
<script>
//TODO: some indicator that meeple has or hasn't been placed
//TODO: show socket status on page
//TODO: indicate move has been sent
function menuClick(menuToOpen, button) {
	$('#menus > div').hide();
	$(menuToOpen).show();
	$('#menu-selection > div').css('fill','#272727');
	$(button).css('fill','#808080');
}

function enableFriendsEdit(e) {
	$('#friends-list .fa-user').removeClass('fa-user').addClass('fa-trash-o').css('cursor', 'pointer').on('click', function () {
		socket.emit('remove friend', this.parentNode.id.substr(7));
		$(this.parentNode).remove();
	});
	$(window).on('click.friend-edit', function() {
		disableFriendsEdit();	
	});
	e.stopPropagation();
}

function disableFriendsEdit() {
	$('#friends-list .fa-trash-o').removeClass('fa-trash-o').addClass('fa-user').css('cursor', '').off('click');
	$(window).off('click.friend-edit');
}

function enableGamesEdit(e) {
	$('#game-menu .tile-count').hide();
	$('#game-menu .fa-trash-o').removeClass('hidden').on('click', function () {
		socket.emit('remove game', this.parentNode.parentNode.id.substr(5));
		$(this.parentNode.parentNode).remove();
	});
	$(window).on('click.games-edit', function() {
		disableGamesEdit();	
	});
	e.stopPropagation();
}

function disableGamesEdit() {
	$('#game-menu .fa-trash-o').addClass('hidden').off('click');
	$('#game-menu .tile-count').show();
	$(window).off('click.games-edit');
}

var user = <%- JSON.stringify(user) %>;

(function ($) {
    // debouncedresize: special jQuery event that happens once after a window resize
    // https://github.com/louisremi/jquery-smartresize
    // Copyright 2012 @louis_remi
    // Licensed under the MIT license.
    var $event = $.event,
        $special,
        resizeTimeout;
    $special = $event.special.debouncedresize = {
        setup: function () { $(this).on("resize", $special.handler); },
        teardown: function () { $(this).off("resize", $special.handler); },
        handler: function (event, execAsap) {
            // Save the context
            var context = this,
                    args = arguments,
                    dispatch = function () {
                        // set correct event type
                        event.type = "debouncedresize";
                        $event.dispatch.apply(context, args);
                    };
            if (resizeTimeout) {
                clearTimeout(resizeTimeout);
            }
            execAsap ? dispatch() : resizeTimeout = setTimeout(dispatch, $special.threshold);
        },
        threshold: 150
    };
})(jQuery);
//TODO: show player names or avatars
//TODO: have first game autoload
//TODO: have visual indicator of ability to rotate
//TODO: Modernizr and noscript redirects

//TODO: move these variables out of the global namespace (add onclick to elements via JS)
var socket = io.connect('<%- process.env.SOCKET_URL %>');
var currentGameID, selectedMove, svgHeight, svgWidth;
var reverseScale = 1;
var reverseTranslation = [0,0];
var transitionDuration = 750;
var tileSize = 100;
	
function resetActiveTile(withTransition) {
	// remove data stored regarding the active tile position
	$('#active-tile').removeData('rotationIndex').removeData('placementIndex');
	// hide any placed meeples and their outlines
	$('#meeple-placements image').attr('visibility', 'hidden');
	// show the meeples in the score area as they are no longer placed
	$('#score-area image').first().removeAttr('visibility');
	// remove any selected move
	selectedMove = null;
	
	if(withTransition) {
		var startingScale = reverseScale;
		var startingTranslationX = reverseTranslation[0];
		var startingTranslationY = reverseTranslation[1];
		d3.select('#confirm-button').transition().duration(transitionDuration).attr('opacity', 0);
		d3.select('#confirm-button').transition().delay(transitionDuration).attr('visibility', 'hidden');
		d3.select('#active-tile').transition().duration(transitionDuration).attr({ 
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		}).each('end', function() {
			// check to see if zoom or pan has happened since this transition began and redraw if so
			if(reverseScale !== startingScale || 
			   reverseTranslation[0] !== startingTranslationX ||
			   reverseTranslation[1] !== startingTranslationY) {
				resetActiveTile(true);   	
	   		}
		});
	} else {
		d3.select('#confirm-button').transition().duration(0).attr({
			opacity: 0,
			visibility: 'hidden'
		});
		d3.select('#active-tile').attr({ 
			transform: 'scale(' + reverseScale + ') translate(' + (reverseTranslation[0] + (svgWidth - tileSize - 5)) + ',' + (reverseTranslation[1] + 5) + ')'
		}).select('#active-tile-rotation').attr({
			transform: 'rotate(0)'
		});
	}
}

$(document).ready(function() {
	// maybe avoid getting some spam with this
	$('#author-name').replaceWith('<a href="mailto:' + 'btouellette+concarneau' + '@' + 'gmail.com' + '">Brian Ouellette</a>');
	
	$('#btc-donate').qtip({
		prerender: true,
		content: {
			text: '<img src="/content/images/ui/bitcoin_qr.png" class="btc-qr"></img>13C6vXxhQuSrGs628imU8ug2xvachM6pJ2'
		},
		style: {
			classes: 'qtip-bootstrap'
		},
		position: {
			my: 'bottom center',
			at: 'top center',
			viewport: $(window), 
            adjust: {
                method: 'shift'
            }
		},
		show: {
			event: 'mouseenter click',
			delay: 200
		},
		hide: {
			event: 'unfocus mouseleave',
			delay: 500
		},
		events: {
            render: function(event, api) {
            	$(this).attr('id', 'btc-popup');
                // detect when it was clicked and store it
                api.elements.target.click(function(e) { 
                    api.wasClicked = !api.wasClicked;
                });
            },
            hide: function(event, api) {
                // if we're hiding and it was previously clicked stop, if it gets hidden unset the clicked status
                if((api.wasClicked && (event.originalEvent.type === 'mouseleave' || event.originalEvent.type === 'mouseout')) ||
                   $('#btc-popup').is(":hover")) {
                    try{ event.preventDefault(); } catch(e) {}
                } else {
                	api.wasClicked = false;
                }
            }
        }
	});
	
	$('#game-menu .fa-plus-square-o').qtip({
		content: {
			text: '<div id="new-game-popup">' + 
			        '<div>Add friends to game:</div>' + 
			      '</div>' + 
			      '<button type="button" id="new-game-cancel" class="btn btn-default btn-sm">Cancel</button>' + 
			      '<button id="new-game-send" type="button" class="btn btn-default btn-sm">Start</button>'
		},
		style: {
			classes: 'qtip-bootstrap',
			tip: {
				corner: false
			}
		},
		position: {
			my: 'left center',
			at: 'center right',
			viewport: $(window), 
            adjust: {
                method: 'shift',
                x: 225
            }
		},
		show: {
			event: 'click'
		},
		hide: {
			event: 'click'
		},
		events: {
			show: function() {
				$('#friends-menu .fa-edit').hide();
				$('#friends-menu-selection').click();
				$('#friends-list .fa-user').removeClass('fa-user').addClass('fa-plus-square-o').css('cursor', 'pointer');
				$('#friends-list .friend-listing').on('click', function() {
					if($('#new-game-popup .friend-listing').length < 4) {
						var element = $(this);
						element.clone().attr('id', 'add-' + element.attr('id')).addClass('add-friend-listing').appendTo('#new-game-popup');
					}
				});
			},
			hide: function() {
				$('#friends-menu .fa-edit').show();
				$('#game-menu-selection').click();
				$('#friends-list .fa-plus-square-o').removeClass('fa-plus-square-o').addClass('fa-user').css('cursor', '');
				$('#friends-list .friend-listing').off('click');
			},
			render: function(e, api) {
                $('#new-game-cancel', this).click(function(event) {
                    api.hide(event);
                    event.preventDefault();
                });
                $('#new-game-send', this).click(function(event) {
                	var friends = [];
                	$('.add-friend-listing').each(function() {
                		friends.push(this.id.substr(11));
                	});
                	socket.emit('new game', friends);
                	api.hide(event);
                	event.preventDefault();
                });
			}
		}
	});

	$('#add-friend-form').on('submit', function(e) {
		e.preventDefault();
		socket.emit('add friend', $('#add-friend-input').val());
	});
	
	$('#chat-message-form').on('submit', function(e) {
		e.preventDefault();
		var input = $('#chat-message-input');
		socket.emit('sending message', input.val(), currentGameID);
		input.val('');
	});

	// Load in SVG icons
	var c = new XMLHttpRequest();
	c.open('GET', '/content/images/ui/icons.svg', false);
	c.setRequestHeader('Content-Type', 'text/xml');
	c.send();
	document.body.insertBefore(c.responseXML.firstChild, document.body.firstChild);

    var lastGamestate;
    
    var zoom = d3.behavior.zoom().scaleExtent([0.25, 1]).on('zoom', function() {
    	//d3.event.sourceEvent.preventDefault();
		reverseScale = 1/d3.event.scale;
		reverseTranslation = d3.event.translate.map(function(item) { return -1 * item; });
		gameArea.attr('transform', 'translate(' + d3.event.translate + ') scale(' + d3.event.scale + ')');
		if(!selectedMove) {
			resetActiveTile(false);
		}
	});
	
	//TODO: zoom and pan when active tile moves if out of zoom/pan range
	//TODO: default zoom level should be dependendent on number of placed tiles
	//TODO: see if there is a way to prevent the image rerender across the board when the active tile is scaled

    var svg = d3.select('#game-svg').call(zoom);
	
	var gameArea = svg.append('g').attr({ id: 'game-area' });
    var placedTiles = gameArea.append('g').attr({ id: 'placed-tiles' });
    var turnMarkerArea = gameArea.append('g').attr({ id: 'turn-markers' });
	var placements = gameArea.append('g').attr({ id: 'valid-placements' });
    var activeTileContainer = gameArea.append('g').attr({ id: 'active-tile' });
    var activeTileImageContainer = activeTileContainer.append('g').attr({ id: 'active-tile-translation', transform: 'translate(' + tileSize / 2 + ',' + tileSize / 2 + ')' })
                                                      .append('g').attr({ id: 'active-tile-rotation' });
    var meeplePlacements = activeTileImageContainer.append('g').attr({ id: 'meeple-placements' });
	
    var uiArea = svg.append('g').attr({ id: 'ui-area' });
    var scoreArea = uiArea.append('g').attr({ id: 'score-area' });
    var confirmButton = uiArea.append('g').attr({
    	id: 'confirm-button',
    	cursor: 'pointer',
    	visibility: 'hidden'
    }).on('click', function() {
    	if(selectedMove) {
    		socket.emit('sending move', currentGameID, selectedMove, false);
    	}
    });
    confirmButton.append('circle').attr({
    	cy: 5 + tileSize / 2,
    	cx: $('#svg-wrapper').width() - 5 - tileSize / 2,
    	r: 30,
    	fill: 'green',
    	stroke: 'black',
    	'stroke-width': 5
    });
    confirmButton.append('use').attr({
    	'xlink:href': '#svgicon-selecting-from-list',
    	x: $('#svg-wrapper').width() - 5 - tileSize / 2 - 16,
    	y: 5 + tileSize / 2 - 16
    });
    
	function addNewGameListing(game, menuGroup) {
		var gameID = game._id;
		
		var element = '<div class="menu-game-listing" id="game-' + gameID + '">';
		// add remaining tiles text
		element += '<span class="right-side"><span class="tile-count">[' + game.unusedTiles.length + ']</span><i class="fa fa-trash-o hidden"></i></span>';
		// add sub divs for each user in the game
		element += game.players.map(function(item) {
   			return '<div class="game-player-listing">' + (item.active ? '&lt;' + item.user.username+ '&gt;' : item.user.username) + '</div>';
     		}).join('');
     		element += '</div>';
     		
   		$(element).click(function() {
     	  	socket.emit('load game', gameID);
     	  	$('#chat-wrapper').removeClass('hidden');
     	  	currentGameID = gameID;
		}).appendTo(menuGroup);
	}
    
    function drawMenu(user) {
    	//TODO: add and test transitions
    	// set up the game menu
        var $gameListings = $('#game-menu');
        var $activeGames = $('#active-games');
        var $inactiveGames = $('#inactive-games');
        var $finishedGames = $('#finished-games');
        var userGames = user.activeGames;
        // add the active games and separate waiting and finished games
        for(var i = 0; i < userGames.length; i++) {
        	if(userGames[i].finished) {
    		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
    		   		$('#game-' + userGames[i]._id).appendTo($finishedGames);
    		   	} else {
    		   		addNewGameListing(userGames[i], $finishedGames);
    		   	}
        	} else {
	        	var active = false;
	        	for(var k = 0; k < userGames[i].players.length; k++) {
	        		if(userGames[i].players[k].user._id === user._id &&
	        		   userGames[i].players[k].active) {
	        		   	active = true;
	        		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
	        		   		$('#game-' + userGames[i]._id).appendTo($activeGames);
	        		   	} else {
    		   				addNewGameListing(userGames[i], $activeGames);
	        		   	}
	        			break;
	        		}
	        	}
	        	if(!active) {
        		   	if($gameListings.has('#game-' + userGames[i]._id).length) {
        		   		$('#game-' + userGames[i]._id).appendTo($inactiveGames);
        		   	} else {
    		   				addNewGameListing(userGames[i], $inactiveGames);
        		   	}
	        	}
        	}
        }
        // set up the friends menu
        var friends = user.friends.sort(function(a, b) {
        	var username_a = a.username.toLowerCase();
        	var username_b = b.username.toLowerCase();
        	if(username_a  > username_b) {
        		return 1;
        	}
        	if(username_a < username_b) {
        		return -1;
        	}
        	return 0;
        });
        var $friendsList = $('#friends-menu');
        for(var j = 0; j < friends.length; j++) {
        	if($friendsList.has('#friend-' + friends[j]._id).length === 0) {
        		// insert the new friend in alphabetical order by display name
        		var element = '<div class="friend-listing" id="friend-' + friends[j]._id + '"><i class="fa fa-user"></i> ' + friends[j].username + '</div>';
        		if(j === 0) {
        			$(element).appendTo("#friends-list");
        		} else {
    				$(element).insertAfter('#friend-' + friends[j-1]._id);
        		}
        	}
        }
    }
    drawMenu(user);
    
    // reset the active tile if the user clicks the background and isn't doing a zoom/pan
    d3.select('#game-background').on('click', function() {
    	if (d3.event.defaultPrevented === false) {
    		resetActiveTile(true);
		}
	});
    // update the SVG on resize
    $(window).on("debouncedresize", function () { if(lastGamestate) { draw(lastGamestate); }});  
    // listen for new gamestate data from the server
    socket.on('sending gamestate', function(gamestate, loadingGame) {
    	console.log(gamestate);
    	// update the tile count in the menu
    	$('#game-' + gamestate._id + ' .tile-count').text('[' + gamestate.unusedTiles.length + ']');
    	// put the game listing in the correct place in the menu
        var $activeGames = $('#active-games');
        var $inactiveGames = $('#inactive-games');
        var $finishedGames = $('#finished-games');
        var $newGame = $('#game-' + gamestate._id);
    	if(gamestate.finished) {
    		if($finishedGames.has($newGame).length === 0) {
	   			$newGame.appendTo($finishedGames);
    		}
    	} else {
        	var active = false;
        	for(var k = 0; k < gamestate.players.length; k++) {
        		if(gamestate.players[k].user._id === user._id &&
        		   gamestate.players[k].active) {
        		   	active = true;
    				if($activeGames.has($newGame).length === 0) {
	    		   		$newGame.appendTo($activeGames);
    				}
        			break;
        		}
        	}
        	if(!active) {
				if($inactiveGames.has($newGame).length === 0) {
	   				$newGame.appendTo($inactiveGames);
				}
        	}
    	}
    	document.title = '(!) Concarneau';
    	$('body').on('mousemove', function() { 
			document.title = 'Concarneau';
			$('body').off('mousemove');
		});
		if(loadingGame) {
			// draw chat messages into chat box
			$('#chat-header-label span').text(' Chat');
			var $chatBody = $('#chat-body');
			var $messageList = $('#chat-message-list').detach();
			$messageList.empty();
			var index = 0;
			while(index < gamestate.messages.length) {
				var username = gamestate.messages[index].username;
				var messageGroup = [];
				while(messageGroup.length === 0 ||
				      (index < gamestate.messages.length && gamestate.messages[index].username === username)) {
					messageGroup.push(gamestate.messages[index].message);
					index++
				}
				var $li = $('<li>').append($('<div class="chat-user-name">').text(username + ':'));
				for(var j = 0; j < messageGroup.length; j++) {
					$li.append($('<div class="chat-message">').text(messageGroup[j]));
				}
				$messageList.append($li);
			}
			$chatBody.append($messageList);
			// scroll chat messages to botoom
			$chatBody.scrollTop($chatBody[0].scrollHeight);
			$('#chat-footer input').val('');
		}
		if(currentGameID === gamestate._id) {
			draw(gamestate);
		}
	});
	socket.on('game started', function(gamestate, startingUserID) {
    	console.log(gamestate);
		// add to active or inactive games depending on which this player is
        var $activeGames = $('#active-games');
        var $inactiveGames = $('#inactive-games');
    	var active = false;
    	for(var k = 0; k < gamestate.players.length; k++) {
    		if(gamestate.players[k].user._id === user._id &&
    		   gamestate.players[k].active) {
    		   	active = true;
   				addNewGameListing(gamestate, $activeGames);
    			break;
    		}
    	}
    	if(!active) {
   			addNewGameListing(gamestate, $inactiveGames);
    	}
		// draw if this user triggered the new game
		if(user._id === startingUserID) {
			$('#chat-header-label span').text(' Chat');
			$('#chat-message-list').empty();
			currentGameID = gamestate._id;
			draw(gamestate);
		}	
    	document.title = '(!) Concarneau';
    	$('body').on('mousemove', function() { 
			document.title = 'Concarneau';
			$('body').off('mousemove');
		});
	});
	socket.on('friend added', function(username, userID) {
		var $alert = $('#username-alert');
		$alert.text('Added!');
		$alert.removeClass('alert-danger').addClass('alert-success').fadeTo(0, 1).fadeTo(3500, 0);
		// insert into the friends list alphabetically
		var element = '<div class="friend-listing" id="friend-' + userID + '"><i class="fa fa-user"></i> ' + username + '</div>';
		var $listings = $('.friend-listing');
		if($listings.length === 0) {
			$(element).appendTo('#friends-list');
		} else {
			$listings.each(function(index) {
				if($listings.length <= index + 1 ||
				   $($listings[index+1]).text().trim() > username) {
					$(element).insertAfter(this);
					return false;
				}
			});
		}
	});
	socket.on('friend not found', function() {
		var $alert = $('#username-alert');
		$alert.text('Username not found!');
		$alert.removeClass('alert-success').addClass('alert-danger').fadeTo(0, 1).fadeTo(3500, 0);
	});
	socket.on('message sent', function(message, username, gameID) {
		// add any received messages for the current game to the chatbox
		if(gameID === currentGameID) {
			var $chatBody = $('#chat-body');
			var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
			// add the message either to the username group if it hasn't changed or create a new one
			if($('.chat-user-name').last().text() === username + ':') {
				$('#chat-message-list li').last().append($('<div class="chat-message">').text(message));
			} else {
				$('#chat-message-list').append(
					$('<li>').append(
						$('<div class="chat-user-name">').text(username + ':')
					).append(
						$('<div class="chat-message">').text(message)
					)
				);
			}
			// scroll the chat list down if the user is at the bottom of it otherwise inform of the new message
			if(scrolledToBottom && !$chatBody.is(':hidden')) {
				$chatBody.scrollTop($chatBody[0].scrollHeight);
			} else {
				$('#chat-header-label span').text(' Chat (!)');
				$('#chat-toggle a').on('click.update-header', function() {
					$('#chat-header-label span').text(' Chat');
					$(this).off('click.update-header');
				})
				$chatBody.bind('scroll', function(e) {
					var $chatBody = $(e.currentTarget);
					var scrolledToBottom = $chatBody[0].scrollHeight - $chatBody.scrollTop() == $chatBody.outerHeight();
					if(scrolledToBottom) {
						$('#chat-header-label span').text(' Chat');
						$chatBody.off('scroll');
					}
				});
			}
		}
	});
    
    function draw(gamestate) {
        svgHeight = $('#svg-wrapper').height();
        svgWidth = $('#svg-wrapper').width();
        // if this SVG isn't visible don't update it
        if (svgWidth === 0 || svgHeight === 0) {
            return;
        }
        
    	lastGamestate = gamestate;
    	
    	d3.select('#confirm-button > circle').attr({
    		cx: svgWidth - 5 - tileSize / 2
    	});
    	d3.select('#confirm-button > use').attr({
    		x: svgWidth - 5 - tileSize / 2 - 16
    	});
    	
    	resetActiveTile(false);
    	
		// rotate the player array such that this player is on top
		// go through the entire array to ensure that if this player is in the game multiple times the active version is on top
		var playerCount = gamestate.players.length;
		var count = 0;
    	var reorderedPlayers = gamestate.players.slice(0);
		while(reorderedPlayers[0].user._id !== user._id ||
		      (!reorderedPlayers[0].active && count < playerCount)) {
	      	count++;
			reorderedPlayers.push(reorderedPlayers.shift());
		}
		// get the number of remaining meeples and the color
		var meepleColor = reorderedPlayers[0].color;
		var remainingMeeples = reorderedPlayers[0].remainingMeeples;
		var userIsActive = reorderedPlayers[0].active;
    	
        // for all newly placed tiles: add a group for the placed tile and its meeples
        // then draw the tile image
        var tileGroup = placedTiles.selectAll('g.placed-tile').data(gamestate.placedTiles);
        tileGroup.enter().append('g').attr({
        	class: 'placed-tile'
    	}).append('image').attr({
            x: function(d) { return 0; },
            y: function(d) { return 0; },
            width: tileSize,
            height: tileSize,
            'xlink:href': function(d) { return d.tile.imageURL; }
        });
        tileGroup.attr({
        	transform: function(d) { 
        		var x = svgWidth / 2 + d.x * tileSize;
        		var y = svgHeight / 2 + d.y * tileSize;
        		return 'rotate(' + 90 * d.rotation + ',' + (x + tileSize / 2) + ',' + (y + tileSize / 2) + ') translate(' + x + ',' + y + ')';
    		}
        });
        tileGroup.exit().remove();
        // then draw the meeples placed on all tiles
        var meepleImages = tileGroup.selectAll('image.meeple').data(function(d) {
    		return d.meeples.map(function(item) { 
        		return {
        			color: gamestate.players[item.playerIndex].color,
        			rotation: d.rotation,
        			location: item.placement.locationType,
        			meepleOffset:
            			item.placement.locationType === 'cloister' ? 
	            			{ x: 1/2, y: 1/2 } :
	            		item.placement.locationType === 'city' ?
	            			d.tile['cities'][item.placement.index].meepleOffset :
	            			d.tile[item.placement.locationType + 's'][item.placement.index].meepleOffset
        		};
    		});
    	});
    	// adding any new meeples
    	meepleImages.enter().append('image').attr({
        	class: 'meeple',
        	x: function(d) { return (d.meepleOffset.x - 1/8) * tileSize; },
			y: function(d) { return (d.meepleOffset.y - 1/8) * tileSize; },
			width: tileSize / 4,
			height: tileSize / 4,
			'xlink:href': function(d) { 
				return '/content/images/meeples/' + d.color + '_' + (d.location === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			transform: function(d) { 
				return 'rotate(' + d.rotation * -90 + ',' + d.meepleOffset.x * tileSize + ',' + d.meepleOffset.y * tileSize + ')'; 
			}
        });
        // and removing any meeples that have been picked up
        meepleImages.exit().remove();
        
    	// draw the active tile
    	var activeTileImage = activeTileImageContainer.selectAll('image.active-tile-image').data(gamestate.activeTile.tile ? [gamestate.activeTile.tile] : []);
        activeTileImage.enter().insert('image', '#meeple-placements').attr({
            width: tileSize,
            height: tileSize,
            class: 'active-tile-image',
            'pointer-events': 'none'
        });
        // reset to the base position and update the image URL every draw
        activeTileImage.attr({
			x: -tileSize / 2,
			y: -tileSize / 2,
            'xlink:href': function(d) { return d.imageURL; }
        });
        activeTileImage.exit().remove();
		//TODO: show discarded tiles being tossed
		
		// draw the places where the active tile can be placed
		var validPlacements = placements.selectAll('image.tile-placements').data(userIsActive ? gamestate.activeTile.validPlacements : []);
		validPlacements.enter().append('image').attr({
			class: 'tile-placements',
			id: function(d, i) { return 'placement-' + i; },
            width: tileSize,
            height: tileSize,
            'xlink:href': '/content/images/ui/placement_available.png'
		});
		validPlacements.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
            y: function(d) { return svgHeight / 2 + d.y * tileSize; }
		}).on('click', function (d, i) {
			var $activeTile = $('#active-tile');
			var rotationIndex;
			// if we have previously clicked this placement box move to the next valid rotation
			if($activeTile.data('placementIndex') === i) {
				rotationIndex = ($activeTile.data('rotationIndex') + 1) % d.rotations.length;
			} else {
				// if this is a new location reset to the first rotation
				rotationIndex = 0;
				// hide any placed meeples
				$('#meeple-placements .placed-meeple').attr('visibility', 'hidden');
				$('#score-area image').first().removeAttr('visibility');
				// and reset the move
				selectedMove = { 
					placement: gamestate.activeTile.validPlacements[i]
				};
				d3.select('#confirm-button').transition().duration(0).attr('visibility', null);
				d3.select('#confirm-button').transition().duration(transitionDuration).attr('opacity', 1);
			}
			selectedMove.rotation = d.rotations[rotationIndex].rotation;
			var rotationDegrees = selectedMove.rotation * 90;
			// store data about this selection in the active tile
			$activeTile.data('rotationIndex', rotationIndex);
			$activeTile.data('placementIndex', i);
			// move the active tile over top of the placement box
			var x = parseInt($(this).attr('x'), 10);
			var y = parseInt($(this).attr('y'), 10);
			d3.select('#active-tile').transition().duration(transitionDuration).attr({
				transform: 'translate(' + x + ',' + y + ')'
			});
			d3.select('#active-tile-rotation').transition().duration(transitionDuration).attr({
				transform: 'rotate(' + rotationDegrees + ')'
			});
			if(remainingMeeples > 0) {
				// show outlines for any valid meeple placements and
    			// rotate the meeple placeholders and hidden placed meeples to upright positions
				var validMeeplePlacements = d.rotations[rotationIndex].meeples;
				var container = d3.select('#meeple-placements');
				container.selectAll('image.meeple-outline').transition().duration(transitionDuration).attr({
					visibility: function(d) {
						for(var i = 0; i < validMeeplePlacements.length; i++) {
							if(validMeeplePlacements[i].locationType === d.type &&
							   validMeeplePlacements[i].index === d.index) {
								// remove hidden visibility attribute
								return null;
							}
						}
						return 'hidden';
					},
					transform: function() { 
						return 'rotate(' + -rotationDegrees + ')';
					}
				});
				// remove meeple placement from the move and hide placed meeple if old placement is no longer valid
				container.selectAll('image.placed-meeple').transition().duration(transitionDuration).attr({
					visibility: function(d) {
						
						for(var i = 0; i < validMeeplePlacements.length; i++) {
							if(validMeeplePlacements[i].locationType === d.type &&
							   validMeeplePlacements[i].index === d.index) {
								// remove hidden visibility attribute
								return $(this).attr('visibility');
							}
						}
						if(selectedMove.meeple &&
						   selectedMove.meeple.type === d.type &&
						   selectedMove.meeple.index === d.index) {
							$('#score-area image').first().removeAttr('visibility');
							delete selectedMove.meeple;
						}
						return 'hidden';
					},
					transform: function() { 
						return 'rotate(' + -rotationDegrees + ')';
					}
				});
			}
		});
		validPlacements.exit().remove();
			
		// draw the potential meeple placement for the active tile
		var allMeepleLocations = [];
		if(gamestate.activeTile.tile) {
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.roads.map(function(item, index) { item.type = 'road'; item.index = index; return item; }));
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.farms.map(function(item, index) { item.type = 'farm'; item.index = index; return item; }));
			allMeepleLocations = allMeepleLocations.concat(gamestate.activeTile.tile.cities.map(function(item, index) { item.type = 'city'; item.index = index; return item; }));
			if(gamestate.activeTile.tile.cloister) {
				allMeepleLocations = allMeepleLocations.concat([{ type: 'cloister', index: 1, meepleOffset: { x: 1/2, y: 1/2 }}]);
			}
		}
		// if there were none of a certain type remove all undefined elements added to the array
		allMeepleLocations = allMeepleLocations.filter(function(n) { return n !== undefined; });
		// don't display meeple locations if we can't place meeples
		if(remainingMeeples === 0 || !userIsActive) {
			allMeepleLocations = [];
		}
		// draw the outlines on which meeples can be placed
		var meepleOutlines = meeplePlacements.selectAll('g.outline-group').data(allMeepleLocations);
		var meepleGroup = meepleOutlines.enter().append('g').attr({
			class: 'outline-group'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'meeple-outline'
		});
		meepleGroup.append('image').attr({
			width: tileSize / 4,
			height: tileSize / 4,
			class: 'placed-meeple'
		});
		meepleOutlines.attr({
			transform: function(d) {
				return 'translate(' + (d.meepleOffset.x - 1/2) * tileSize + ',' + (d.meepleOffset.y - 1/2) * tileSize + ')';
			}
		});
		meepleOutlines.select('image.meeple-outline').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) {
				return '/content/images/meeples/outline_' + (d.type === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// when an outline is clicked grab the leftmost available meeple and move it onto the outline
			var $placedMeeples = $('.placed-meeple');
			$placedMeeples.attr('visibility', 'hidden');
			$(this).siblings('.placed-meeple').first().removeAttr('visibility');
			$('#score-group-' + meepleColor + ' image').first().attr('visibility', 'hidden');
			selectedMove.meeple = {
				type: d.type,
				index: d.index
			};
		});
		meepleOutlines.select('image.placed-meeple').attr({
			x: -tileSize / 8,
			y: -tileSize / 8,
			'xlink:href': function(d) { 
				return '/content/images/meeples/' + meepleColor + '_' + (d.type === 'farm' ? 'lying' : 'standing') +'.png'; 
			},
			visibility: 'hidden'
		}).on('click', function(d, i) {
			// when a visible meeple is clicked hide it and remove it from the move
			$(this).attr('visibility', 'hidden');
			$('#score-group-' + meepleColor + ' image').first().removeAttr('visibility');
			delete selectedMove.meeple;
		});
		meepleOutlines.exit().remove();

		// draw outlines indicating the last tile each player placed
		var markers = [];
		var index = 0;
		while(gamestate.players[index].active !== undefined && !gamestate.players[index].active) {
			index++;
		}
		index++;
		for(var k = 0; k < Math.min(gamestate.players.length, gamestate.placedTiles.length - 1); k++) {
			if(gamestate.placedTiles.length - (k+1) > 0) {
				markers.push({
					x: gamestate.placedTiles[gamestate.placedTiles.length - (k+1)].x,
					y: gamestate.placedTiles[gamestate.placedTiles.length - (k+1)].y,
					color: gamestate.players[(index + k) % gamestate.players.length].color
				});
			}
		}
		
		var turnMarkers = turnMarkerArea.selectAll('rect.turn-marker').data(markers);
		turnMarkers.enter().append('rect').attr({
			class: 'turn-marker',
			'fill-opacity': 0,
			'stroke-width': 3,
			'stroke-linejoin': 'round',
			rx: 7,
			ry: 7,
			width: tileSize,
			height: tileSize
		});
		turnMarkers.attr({
			x: function(d) { return svgWidth / 2 + d.x * tileSize; },
			y: function(d) { return svgHeight / 2 + d.y * tileSize; },
			stroke: function(d) { return d.color; }
		});
		turnMarkers.exit().remove();
		
		//TODO: draw score with nicer background/styling
		// draw the players scores and remaining meeples
		var scoreGroups = scoreArea.selectAll('g.score-group').data(reorderedPlayers);
		var group = scoreGroups.enter().append('g').attr({
			class: 'score-group'
		});
		scoreGroups.attr({
			id: function(d) {
				return 'score-group-' + d.color;
			}
		});
		group.append('text').attr({
			class: 'point-total',
			x: 5,
			y: function(d, i) {
				return 5 + (6 + tileSize / 8) + i*(tileSize / 4);
			}
		});
		scoreGroups.select('text.point-total').text(function(d) { return d.points; }).attr({
			style: function(d) {
				var style = 'font-size:16px;';
				if(d.active) {
					style += 'font-weight:bold;';
				}
				return style;
			}
		});
		scoreGroups.exit().remove();
		
		//TODO: have the active player placed meeple move down from the remaining meeples onto the tile
		var availableMeeples = scoreGroups.selectAll('image.remaining-meeple').data(function(d, i) { 
			var array = [];
			for(var k = 0; k < d.remainingMeeples; k++) {
				array.push({
					x: 20 + (k+1)*(tileSize / 8),
					y: 5 + i*(tileSize / 4),
					url: '/content/images/meeples/' + d.color + '_standing.png'
				});
			}
			array.reverse();
			return array;
		});
		availableMeeples.enter().append('image').attr({
			class: 'remaining-meeple',
			y: function(d) { return d.y; },
			width: tileSize / 4,
			height: tileSize / 4
		});
		availableMeeples.attr({
			x: function(d) { return d.x; },
			'xlink:href': function(d) { return d.url; },
			visibility: null
		});
		availableMeeples.exit().remove();
    }
    //TODO: show unused tile count, clickable to show remaining tile counts
});
</script>
</body>
</html>